<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title>V8</title><subtitle>JavaScript V8 引擎</subtitle><link href="https://v8.js.cn/blog.atom" rel="self"/><link href="https://v8.js.cn/"/><updated>2020-06-30T00:00:00-00:00</updated><id>https://v8.js.cn/</id><author><name>Mathias Bynens</name></author><entry><title>V8 release v8.4</title><link href="https://v8.js.cn/blog/v8-release-84/"/><updated>2020-06-30T00:00:00-00:00</updated><id>https://v8.js.cn/blog/v8-release-84/</id><author><name>Camillo Bruni, enjoying some fresh booleans</name></author><content type="html">&lt;p&gt;Every six weeks, we create a new branch of V8 as part of our &lt;a href=&quot;https://v8.dev/docs/release-process&quot;&gt;release process&lt;/a&gt;. Each version is branched from V8’s Git master immediately before a Chrome Beta milestone. Today we’re pleased to announce our newest branch, &lt;a href=&quot;https://chromium.googlesource.com/v8/v8.git/+log/branch-heads/8.4&quot;&gt;V8 version 8.4&lt;/a&gt;, which is in beta until its release in coordination with Chrome 84 Stable in several weeks. V8 v8.4 is filled with all sorts of developer-facing goodies. This post provides a preview of some of the highlights in anticipation of the release.&lt;/p&gt;
&lt;h2 id=&quot;webassembly&quot;&gt;WebAssembly &lt;a class=&quot;bookmark&quot; href=&quot;#webassembly&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&quot;improved-start-up-time&quot;&gt;Improved start-up time &lt;a class=&quot;bookmark&quot; href=&quot;#improved-start-up-time&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;WebAssembly’s baseline compiler (&lt;a href=&quot;https://v8.dev/blog/liftoff&quot;&gt;Liftoff&lt;/a&gt;) now supports &lt;a href=&quot;https://github.com/WebAssembly/threads&quot;&gt;atomic instructions&lt;/a&gt; and &lt;a href=&quot;https://github.com/WebAssembly/bulk-memory-operations&quot;&gt;bulk memory operations&lt;/a&gt;. This means that even if you use these pretty recent spec additions, you get blazingly fast start-up times.&lt;/p&gt;
&lt;h3 id=&quot;better-debugging&quot;&gt;Better debugging &lt;a class=&quot;bookmark&quot; href=&quot;#better-debugging&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In an ongoing effort to improve the debugging experience in WebAssembly, we are now able to inspect any WebAssembly frame that is live whenever you pause execution or reach a breakpoint.&lt;br&gt;
This was realized by re-using &lt;a href=&quot;https://v8.dev/blog/liftoff&quot;&gt;Liftoff&lt;/a&gt; for debugging. In the past, all code that had breakpoints or was stepped through needed to execute in the WebAssembly interpreter, which slowed down execution substantially (often around 100×). With Liftoff, you only lose about one third of your performance, but you can step through all code and inspect it at any time.&lt;/p&gt;
&lt;h3 id=&quot;simd-origin-trial&quot;&gt;SIMD Origin Trial &lt;a class=&quot;bookmark&quot; href=&quot;#simd-origin-trial&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The SIMD proposal enables WebAssembly to take advantage of commonly available hardware vector instructions to accelerate compute intensive workloads. V8 has &lt;a href=&quot;https://v8.dev/features/simd&quot;&gt;support&lt;/a&gt; for the &lt;a href=&quot;https://github.com/WebAssembly/simd&quot;&gt;WebAssembly SIMD proposal&lt;/a&gt;. To enable this in Chrome, use the flag &lt;code&gt;chrome://flags/#enable-webassembly-simd&lt;/code&gt; or sign up for an &lt;a href=&quot;https://developers.chrome.com/origintrials/#/view_trial/-4708513410415853567&quot;&gt;origin trial&lt;/a&gt;. &lt;a href=&quot;https://github.com/GoogleChrome/OriginTrials/blob/gh-pages/developer-guide.md&quot;&gt;Origin trials&lt;/a&gt; allow developers to experiment with a feature before it is standardized, and provide valuable feedback. Once an origin has opted into the trial users are opted into the feature for the duration of the trial period without having to update Chrome flags.&lt;/p&gt;
&lt;h2 id=&quot;javascript&quot;&gt;JavaScript &lt;a class=&quot;bookmark&quot; href=&quot;#javascript&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&quot;weak-references-and-finalizers&quot;&gt;Weak references and finalizers &lt;a class=&quot;bookmark&quot; href=&quot;#weak-references-and-finalizers&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;div class=&quot;note&quot;&gt;
&lt;p&gt;&lt;strong&gt;Warning!&lt;/strong&gt; Weak references and finalizers are advanced features! They depend on garbage collection behavior. Garbage collection is non-deterministic and may not occur at all.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;JavaScript is a garbage collected language, which means memory occupied by objects that are no longer reachable by the program may be automatically reclaimed when the garbage collector runs. With the exception of references in &lt;code&gt;WeakMap&lt;/code&gt; and &lt;code&gt;WeakSet&lt;/code&gt;, all references in JavaScript are strong and prevent the referenced object from being garbage collected. For instance,&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; globalRef &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token function&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;foo&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;// As long as globalRef is reachable through the global scope,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;// neither it nor the function in its callback property will be collected.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JavaScript programmers can now hold on to objects weakly via the &lt;code&gt;WeakRef&lt;/code&gt; feature. Objects that are referenced by weak references do not prevent their being garbage collected if they are not also strongly referenced.&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; globalWeakRef &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;WeakRef&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token function&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;foo&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;  globalWeakRef&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;deref&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token comment&quot;&gt;// Logs “foo” to console. globalWeakRef is guaranteed to be alive&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token comment&quot;&gt;// for the first turn of the event loop after it was created.&lt;/span&gt;&lt;br&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;resolve&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; reject&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;foo&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token comment&quot;&gt;// Wait for a turn of the event loop.&lt;/span&gt;&lt;br&gt;&lt;br&gt;  globalWeakRef&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;deref&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token comment&quot;&gt;// The object inside globalWeakRef may be garbage collected&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token comment&quot;&gt;// after the first turn since it is not otherwise reachable.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The companion feature to &lt;code&gt;WeakRef&lt;/code&gt;s is &lt;code&gt;FinalizationRegistry&lt;/code&gt;, which lets programmers register callbacks to be invoked after an object is garbage collected. For example, the program below may log &lt;code&gt;42&lt;/code&gt; to the console after the unreachable object in the IIFE is collected.&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; registry &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;FinalizationRegistry&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;heldValue&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;heldValue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; garbage &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;  registry&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;register&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;garbage&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token comment&quot;&gt;// The second argument is the “held” value which gets passed&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token comment&quot;&gt;// to the finalizer when the first argument is garbage collected.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finalizers are scheduled to run on the event loop and never interrupt synchronous JavaScript execution.&lt;/p&gt;
&lt;p&gt;These are advanced and powerful features, and with any luck, your program won’t need them. Please see our &lt;a href=&quot;https://v8.dev/features/weak-references&quot;&gt;explainer&lt;/a&gt; to learn more about them!&lt;/p&gt;
&lt;h3 id=&quot;private-methods-and-accessors&quot;&gt;Private methods and accessors &lt;a class=&quot;bookmark&quot; href=&quot;#private-methods-and-accessors&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Private fields, which shipped in v7.4, are rounded out with support for private methods and accessors. Syntactically, the names of private methods and accessors start with &lt;code&gt;#&lt;/code&gt;, just like private fields. The following is a brief taste of the syntax.&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Component&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token function&quot;&gt;#privateMethod&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;I&#39;m only callable inside Component!&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;#privateAccessor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;#privateAccessor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Private methods and accessors have the same scoping rules and semantics as private fields. Please see our &lt;a href=&quot;https://v8.dev/features/class-fields&quot;&gt;explainer&lt;/a&gt; to learn more.&lt;/p&gt;
&lt;p&gt;Thanks to &lt;a href=&quot;https://twitter.com/igalia&quot;&gt;Igalia&lt;/a&gt; for contributing the implementation!&lt;/p&gt;
&lt;h2 id=&quot;v8-api&quot;&gt;V8 API &lt;a class=&quot;bookmark&quot; href=&quot;#v8-api&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Please use &lt;code&gt;git log branch-heads/8.3..branch-heads/8.4 include/v8.h&lt;/code&gt; to get a list of the API changes.&lt;/p&gt;
&lt;p&gt;Developers with an active V8 checkout can use &lt;code&gt;git checkout -b 8.4 -t branch-heads/8.4&lt;/code&gt; to experiment with the new features in V8 v8.4. Alternatively you can &lt;a href=&quot;https://www.google.com/chrome/browser/beta.html&quot;&gt;subscribe to Chrome’s Beta channel&lt;/a&gt; and try the new features out yourself soon.&lt;/p&gt;
</content></entry><entry><title>High-performance garbage collection for C++</title><link href="https://v8.js.cn/blog/high-performance-cpp-gc/"/><updated>2020-05-26T00:00:00-00:00</updated><id>https://v8.js.cn/blog/high-performance-cpp-gc/</id><author><name>Anton Bikineev, Omer Katz (@omerktz), and Michael Lippautz (@mlippautz), C++ memory whisperers</name></author><content type="html">&lt;p&gt;In the past we have &lt;a href=&quot;https://v8.dev/blog/trash-talk&quot;&gt;already&lt;/a&gt; &lt;a href=&quot;https://v8.dev/blog/concurrent-marking&quot;&gt;been&lt;/a&gt; &lt;a href=&quot;https://v8.dev/blog/tracing-js-dom&quot;&gt;writing&lt;/a&gt; about garbage collection for JavaScript, the document object model (DOM), and how all of this is implemented and optimized in V8. Not everything in Chromium is JavaScript though, as most of the browser and its Blink rendering engine where V8 is embedded are written in C++. JavaScript can be used to interact with the DOM that is then processed by the rendering pipeline.&lt;/p&gt;
&lt;p&gt;Because the C++ object graph around the DOM is heavily tangled with Javascript objects, the Chromium team switched a couple of years ago to a garbage collector, called &lt;a href=&quot;https://www.youtube.com/watch?v=_uxmEyd6uxo&quot;&gt;Oilpan&lt;/a&gt;, for managing this kind of memory. Oilpan is a garbage collector written in C++ for managing C++ memory that can be connected to V8 using &lt;a href=&quot;https://research.google/pubs/pub47359/&quot;&gt;cross-component tracing&lt;/a&gt; that treats the tangled C++/JavaScript object graph as one heap.&lt;/p&gt;
&lt;p&gt;This post is the first in a series of Oilpan blog posts which will provide an overview of the core principles of Oilpan and its C++ APIs. For this post we will cover some of the supported features, explain how they interact with various subsystems of the garbage collector, and do a deep dive into concurrently reclaiming objects in the sweeper.&lt;/p&gt;
&lt;p&gt;Most excitingly, Oilpan is currently implemented in Blink but moving to V8 in the form of a &lt;a href=&quot;https://chromium.googlesource.com/v8/v8.git/+/HEAD/include/cppgc/&quot;&gt;garbage collection library&lt;/a&gt;. The goal is to make C++ garbage collection easily available for all V8 embedders and more C++ developers in general.&lt;/p&gt;
&lt;h2 id=&quot;background&quot;&gt;Background &lt;a class=&quot;bookmark&quot; href=&quot;#background&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Oilpan implements a &lt;a href=&quot;https://en.wikipedia.org/wiki/Tracing_garbage_collection&quot;&gt;Mark-Sweep&lt;/a&gt; garbage collector where garbage collection is split among two phases: &lt;em&gt;marking&lt;/em&gt; where the managed heap is scanned for live objects, and &lt;em&gt;sweeping&lt;/em&gt; where dead objects on the managed heap are reclaimed.&lt;/p&gt;
&lt;p&gt;We’ve covered the basics of marking already when introducing &lt;a href=&quot;https://v8.dev/blog/concurrent-marking&quot;&gt;concurrent marking in V8&lt;/a&gt;. To recap, scanning all objects for live ones can be seen as graph traversal where objects are nodes and pointers between objects are edges. Traversal starts at roots which are registers, native execution stack (which we will call stack from now on), and other globals, as described &lt;a href=&quot;https://v8.dev/blog/concurrent-marking#background&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;C++ is not different to JavaScript in that aspect. In contrast to JavaScript though, C++ objects are statically typed and thus cannot change their representation at runtime. C++ objects managed using Oilpan leverage this fact and provide a description of pointers to other objects (edges in the graph) via visitor pattern. The basic pattern for describing Oilpan objects is the following:&lt;/p&gt;
&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;LinkedNode&lt;/span&gt; final &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; GarbageCollected&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;LinkedNode&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt; &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token function&quot;&gt;LinkedNode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;LinkedNode&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; next&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;next_&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;next&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;value_&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Trace&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Visitor&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; visitor&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;    visitor&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;Trace&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;next_&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br&gt; &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;br&gt;  Member&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;LinkedNode&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; next_&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; value_&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;br&gt;LinkedNode&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;CreateNodes&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;  LinkedNode&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; first_node &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; MakeGarbageCollected&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;LinkedNode&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;  LinkedNode&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; second_node &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; MakeGarbageCollected&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;LinkedNode&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;first_node&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; second_node&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the example above, &lt;code&gt;LinkedNode&lt;/code&gt; is managed by Oilpan as indicated by inheriting from &lt;code&gt;GarbageCollected&amp;lt;LinkedNode&amp;gt;&lt;/code&gt;. When the garbage collector processes an object it discovers outgoing pointers by invoking the &lt;code&gt;Trace&lt;/code&gt; method of the object. The type &lt;code&gt;Member&lt;/code&gt; is a smart pointer that is syntactically similar to e.g. &lt;code&gt;std::shared_ptr&lt;/code&gt;, which is provided by Oilpan and used to maintain a consistent state while traversing the graph during marking. All of this allows Oilpan to precisely know where pointers reside in its managed objects.&lt;/p&gt;
&lt;p&gt;Avid readers probably noticed &lt;s&gt;and may be scared&lt;/s&gt; that &lt;code&gt;first_node&lt;/code&gt; and &lt;code&gt;second_node&lt;/code&gt; are kept as raw C++ pointers on the stack in the example above. Oilpan does not add abstractions for working with the stack, relying solely on conservative stack scanning to find pointers into its managed heap when processing roots. This works by iterating the stack word-by-word and interpreting those words as pointers into the managed heap. This means that Oilpan does not impose a performance penalty for accessing stack-allocated objects. Instead, it moves  the cost to the garbage collection time where it scans the stack conservatively. Oilpan as integrated in the renderer tries to delay garbage collection until it reaches a state where it’s guaranteed to have no interesting stack. Since the web is event based and execution is driven by processing tasks in event loops, such opportunities are plentiful.&lt;/p&gt;
&lt;p&gt;Oilpan is used in Blink which is a large C++ codebase with lots of mature code and thus also supports:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Multiple inheritance through mixins and references to such mixins (interior pointers).&lt;/li&gt;
&lt;li&gt;Triggering garbage collection during executing constructors.&lt;/li&gt;
&lt;li&gt;Keeping objects alive from non-managed memory through &lt;code&gt;Persistent&lt;/code&gt; smart pointers which are treated as roots.&lt;/li&gt;
&lt;li&gt;Collections covering sequential (e.g. vector) and associative (e.g. set and map) containers with compaction of collection backings.&lt;/li&gt;
&lt;li&gt;Weak references, weak callbacks, and &lt;a href=&quot;https://en.wikipedia.org/wiki/Ephemeron&quot;&gt;ephemerons&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Finalizer callbacks that are executed before reclaiming individual objects.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;sweeping-for-c%2B%2B&quot;&gt;Sweeping for C++ &lt;a class=&quot;bookmark&quot; href=&quot;#sweeping-for-c%2B%2B&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Stay tuned for a separate blog post on how marking in Oilpan works in detail. For this article we assume marking is done and Oilpan has discovered all reachable objects with the help of their &lt;code&gt;Trace&lt;/code&gt; methods. After marking all reachable objects have their mark bit set.&lt;/p&gt;
&lt;p&gt;Sweeping is now the phase where dead objects (those unreachable during marking) are reclaimed and their underlying memory is either returned to the operating system or made available for subsequent allocations. In the following we show how Oilpan’s sweeper works, both from a usage and constraint perspective, but also how it achieves high reclamation throughput.&lt;/p&gt;
&lt;p&gt;The sweeper finds dead objects by iterating the heap memory and checking the mark bits. In order to preserve the C++ semantics, the sweeper has to invoke the destructor of each dead object before freeing its memory. Non-trivial destructors are implemented as finalizers.&lt;/p&gt;
&lt;p&gt;From the programmer’s perspective, there is no defined order in which destructors are executed, as the iteration used by the sweeper does not consider construction order. This imposes a restriction that finalizers are not allowed to touch other on-heap objects. This is a common challenge for writing user-code that requires finalization order as managed languages generally do not support order in their finalization semantics (e.g. Java). Oilpan uses a Clang plugin that statically verifies, among many other things, that no heap objects are accessed during destruction of an object:&lt;/p&gt;
&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;GCed&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; GarbageCollected&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;GCed&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt; &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;DoSomething&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Trace&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Visitor&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; visitor&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;    visitor&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;Trace&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;other_&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token operator&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;GCed&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;    other_&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;DoSomething&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;// error: Finalizer &#39;~GCed&#39; accesses&lt;/span&gt;&lt;br&gt;                            &lt;span class=&quot;token comment&quot;&gt;// potentially finalized field &#39;other_&#39;.&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br&gt; &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;br&gt;  Member&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;GCed&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; other_&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For the curious: Oilpan provides pre-finalization callbacks for complex use cases that require access to the heap before objects are destroyed. Such callbacks impose more overhead than destructors on each garbage collection cycle though and are only used sparingly in Blink.&lt;/p&gt;
&lt;h2 id=&quot;incremental-and-concurrent-sweeping&quot;&gt;Incremental and concurrent sweeping &lt;a class=&quot;bookmark&quot; href=&quot;#incremental-and-concurrent-sweeping&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Now that we have covered the restrictions of destructors in a managed C++ environment, it is time to look at how Oilpan implements and optimizes the sweeping phase in more detail.&lt;/p&gt;
&lt;p&gt;Before diving into details it is important to recall how programs in general are executed on the web. Any execution, e.g., JavaScript programs but also garbage collection, is driven from the main thread by dispatching tasks in an &lt;a href=&quot;https://en.wikipedia.org/wiki/Event_loop&quot;&gt;event loop&lt;/a&gt;. The renderer, much like other application environments, supports background tasks that run concurrently to the main thread to aid processing any main-thread work.&lt;/p&gt;
&lt;p&gt;Starting out simple, Oilpan originally implemented stop-the-world sweeping which ran as a part of the garbage collection finalization pause interrupting executing of the application on the main thread:&lt;/p&gt;
&lt;figure&gt;&lt;img src=&quot;https://v8.js.cn/_img/high-performance-cpp-gc/stop-the-world-sweeping.svg&quot; alt=&quot;&quot; width=&quot;838&quot; height=&quot;112&quot; loading=&quot;lazy&quot;&gt;&lt;figcaption&gt;Stop-the-world sweeping&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p&gt;For applications with soft real-time constraints the determining factor when dealing with garbage collection is latency. Stop-the-world sweeping may induce a significant pause time resulting in user-visible application latency. As the next step to reduce latency, sweeping was made incremental:&lt;/p&gt;
&lt;figure&gt;&lt;img src=&quot;https://v8.js.cn/_img/high-performance-cpp-gc/incremental-sweeping.svg&quot; alt=&quot;&quot; width=&quot;845&quot; height=&quot;138&quot; loading=&quot;lazy&quot;&gt;&lt;figcaption&gt;Incremental sweeping&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p&gt;With the incremental approach, sweeping is split up and delegated to additional main-thread tasks. In the best case, such tasks are executed completely in &lt;a href=&quot;https://research.google/pubs/pub45361/&quot;&gt;idle time&lt;/a&gt;, avoiding interfering with any regular application execution. Internally, the sweeper divides work into smaller units based on a notion of pages. Pages can be in two interesting states: &lt;em&gt;to-be-swept&lt;/em&gt; pages that the sweeper still needs to process, and &lt;em&gt;already-swept&lt;/em&gt; pages that the sweeper already processed. Allocation only considers already-swept pages and will refill local allocation buffers (LABs) from free lists that maintain a list of available memory chunks. For getting memory from a free list the application will first try to find memory in already-swept pages, then try to help processing to-be-swept pages by inlining the sweeping algorithm into allocation, and only request new memory from the OS in case there is none.&lt;/p&gt;
&lt;p&gt;Oilpan has used incremental sweeping for years but as applications and their resulting object graphs grew bigger and bigger, sweeping started to impact application performance. To improve over incremental sweeping we started leveraging background tasks for concurrent reclamation of memory. There are two basic invariants used to rule out any data races between background tasks executing the sweeper and the application allocating new objects:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The sweeper only processes dead memory which is by definition not reachable by the application.&lt;/li&gt;
&lt;li&gt;The application only allocates on already-swept pages which are by definition not being processed by the sweeper anymore.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Both invariants ensure that there should be no contender for the object and its memory. Unfortunately, C++ heavily relies on destructors which are implemented as finalizers. Oilpan enforces finalizers to run on the main thread to assist developers and rule out data races within the application code itself. To solve this issue, Oilpan defers object finalization to the main thread. More concretely, whenever the concurrent sweeper runs into an object that has a finalizer (destructor), it pushes it onto a finalization queue that will be processed in a separate finalization phase, which is always executed on the main thread also running the application. The overall workflow with concurrent sweeping looks like this:&lt;/p&gt;
&lt;figure&gt;&lt;img src=&quot;https://v8.js.cn/_img/high-performance-cpp-gc/concurrent-sweeping.svg&quot; alt=&quot;&quot; width=&quot;987&quot; height=&quot;327&quot; loading=&quot;lazy&quot;&gt;&lt;figcaption&gt;Concurrent sweeping using background tasks&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p&gt;Since finalizers may require accessing all of the object’s payload, adding the corresponding memory to the free list is delayed till after executing the finalizer. If no finalizers are executed, the sweeper running on the background thread immediately adds the reclaimed memory to the free list.&lt;/p&gt;
&lt;h1 id=&quot;results&quot;&gt;Results &lt;a class=&quot;bookmark&quot; href=&quot;#results&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Background sweeping has shipped in Chrome M78. Our &lt;a href=&quot;https://v8.dev/blog/real-world-performance&quot;&gt;real-world benchmarking framework&lt;/a&gt; shows a reduction of main thread sweeping time by 25%-50% (42% on average). See a selected set of line items below.&lt;/p&gt;
&lt;figure&gt;&lt;img src=&quot;https://v8.js.cn/_img/high-performance-cpp-gc/results.svg&quot; alt=&quot;&quot; width=&quot;600&quot; height=&quot;371&quot; loading=&quot;lazy&quot;&gt;&lt;figcaption&gt;Main thread sweeping time in milliseconds&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p&gt;The remainder of time spent on the main thread is for executing finalizers. There’s ongoing work on reducing finalizers for heavily-instantiated object types in Blink. The exciting part here is that all these optimizations are done in application code as sweeping will automatically adjust in the absence of finalizers.&lt;/p&gt;
&lt;p&gt;Stay tuned for more posts on C++ garbage collection in general and Oilpan library updates specifically as we move closer to a release that can be used by all users of V8.&lt;/p&gt;
</content></entry><entry><title>Understanding the ECMAScript spec, part 4</title><link href="https://v8.js.cn/blog/understanding-ecmascript-part-4/"/><updated>2020-05-19T00:00:00-00:00</updated><id>https://v8.js.cn/blog/understanding-ecmascript-part-4/</id><author><name>Marja Hölttä, speculative specification spectator</name></author><content type="html">&lt;h2 id=&quot;previous-episodes&quot;&gt;Previous episodes &lt;a class=&quot;bookmark&quot; href=&quot;#previous-episodes&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In &lt;a href=&quot;https://v8.js.cn/blog/understanding-ecmascript-part-1&quot;&gt;part 1&lt;/a&gt;, we read through a simple method — &lt;code&gt;Object.prototype.hasOwnProperty&lt;/code&gt; — and the &lt;strong&gt;abstract operations&lt;/strong&gt; it invokes. We familiarized ourselves with the shorthands &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;!&lt;/code&gt; related to error handling. We encountered &lt;strong&gt;language types&lt;/strong&gt;, &lt;strong&gt;specification types&lt;/strong&gt;, &lt;strong&gt;internal slots&lt;/strong&gt;, and &lt;strong&gt;internal methods&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;In &lt;a href=&quot;https://v8.js.cn/blog/understanding-ecmascript-part-2&quot;&gt;part 2&lt;/a&gt;, we examined a simple grammar production and how its runtime semantics are defined. In &lt;a href=&quot;https://v8.js.cn/blog/extra/understanding-ecmascript-part-2-extra&quot;&gt;the extra content&lt;/a&gt;, we also followed a long grammar production chain from &lt;code&gt;AssignmentExpression&lt;/code&gt; to &lt;code&gt;MemberExpression&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In &lt;a href=&quot;https://v8.js.cn/blog/understanding-ecmascript-part-3&quot;&gt;part 3&lt;/a&gt;, we familiarized ourselves with the lexical grammar, the syntactic grammar, and the shorthands used for defining the syntactic grammar.&lt;/p&gt;
&lt;h2 id=&quot;meanwhile-in-other-parts-of-the-web&quot;&gt;Meanwhile in other parts of the Web &lt;a class=&quot;bookmark&quot; href=&quot;#meanwhile-in-other-parts-of-the-web&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jorendorff&quot;&gt;Jason Orendorff&lt;/a&gt; from Mozilla published &lt;a href=&quot;https://github.com/mozilla-spidermonkey/jsparagus/blob/master/js-quirks.md#readme&quot;&gt;a great in-depth analysis of JS syntactic quirks&lt;/a&gt;. Even though the implementation details differ, every JS engine faces the same problems with these quirks.&lt;/p&gt;
&lt;h2 id=&quot;cover-grammars&quot;&gt;Cover grammars &lt;a class=&quot;bookmark&quot; href=&quot;#cover-grammars&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In this episode, we take a deeper look into &lt;em&gt;cover grammars&lt;/em&gt;. They are a way to specify the grammar for syntactic constructs which look ambiguous at first.&lt;/p&gt;
&lt;p&gt;Again, we&#39;ll skip the subscripts for &lt;code&gt;[In, Yield, Await]&lt;/code&gt; for brevity, as they aren&#39;t important for this blog post. See &lt;a href=&quot;https://v8.js.cn/blog/understanding-ecmascript-part-3&quot;&gt;part 3&lt;/a&gt; for an explanation of their meaning and usage.&lt;/p&gt;
&lt;h2 id=&quot;finite-lookaheads&quot;&gt;Finite lookaheads &lt;a class=&quot;bookmark&quot; href=&quot;#finite-lookaheads&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Typically, parsers decide which production to use based on a finite lookahead (a fixed amount of following tokens).&lt;/p&gt;
&lt;p&gt;In some cases, the next token determines the production to use unambiguously. &lt;a href=&quot;https://tc39.es/ecma262/#prod-UpdateExpression&quot;&gt;For example&lt;/a&gt;:&lt;/p&gt;
&lt;pre class=&quot;language-grammar&quot;&gt;&lt;code class=&quot;language-grammar&quot;&gt;&lt;span class=&quot;token production-name&quot;&gt;UpdateExpression&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;LeftHandSideExpression&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;LeftHandSideExpression&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;++&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;LeftHandSideExpression&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;--&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;UnaryExpression&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;UnaryExpression&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we&#39;re parsing an &lt;code&gt;UpdateExpression&lt;/code&gt; and the next token is &lt;code&gt;++&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt;, we know the production to use right away. If the next token is neither, it&#39;s still not too bad: we can parse a &lt;code&gt;LeftHandSideExpression&lt;/code&gt; starting from the position we&#39;re at, and figure out what to do after we&#39;ve parsed it.&lt;/p&gt;
&lt;p&gt;If the token following the &lt;code&gt;LeftHandSideExpression&lt;/code&gt; is &lt;code&gt;++&lt;/code&gt;, the production to use is &lt;code&gt;UpdateExpression : LeftHandSideExpression ++&lt;/code&gt;. The case for &lt;code&gt;--&lt;/code&gt; is similar. And if the token following the &lt;code&gt;LeftHandSideExpression&lt;/code&gt; is neither &lt;code&gt;++&lt;/code&gt; nor &lt;code&gt;--&lt;/code&gt;, we use the production &lt;code&gt;UpdateExpression : LeftHandSideExpression&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;arrow-function-parameter-list-or-a-parenthesized-expression%3F&quot;&gt;Arrow function parameter list or a parenthesized expression? &lt;a class=&quot;bookmark&quot; href=&quot;#arrow-function-parameter-list-or-a-parenthesized-expression%3F&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Distinguishing arrow function parameter lists from parenthesized expressions is more complicated.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Is this the start of an arrow function, like this?&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; a &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; b &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or maybe it&#39;s a parenthesized expression, like this?&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The parenthesized whatever-it-is can be arbitrarily long - we cannot know what it is based on a finite amount of tokens.&lt;/p&gt;
&lt;p&gt;Let&#39;s imagine for a moment that we had the following straightforward productions:&lt;/p&gt;
&lt;pre class=&quot;language-grammar&quot;&gt;&lt;code class=&quot;language-grammar&quot;&gt;&lt;span class=&quot;token production-name&quot;&gt;AssignmentExpression&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;...&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;ArrowFunction&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;ParenthesizedExpression&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token production-name&quot;&gt;ArrowFunction&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;ArrowParameterList&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;ConciseBody&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can&#39;t choose the production to use with a finite lookahead. If we had to parse a &lt;code&gt;AssignmentExpression&lt;/code&gt; and the next token was &lt;code&gt;(&lt;/code&gt;, how would we decide what to parse next? We could either parse an &lt;code&gt;ArrowParameterList&lt;/code&gt; or a &lt;code&gt;ParenthesizedExpression&lt;/code&gt;, but our guess could go wrong.&lt;/p&gt;
&lt;h3 id=&quot;the-very-permissive-new-symbol%3A-cpeaapl&quot;&gt;The very permissive new symbol: &lt;code&gt;CPEAAPL&lt;/code&gt; &lt;a class=&quot;bookmark&quot; href=&quot;#the-very-permissive-new-symbol%3A-cpeaapl&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The spec solves this problem by introducing the symbol &lt;code&gt;CoverParenthesizedExpressionAndArrowParameterList&lt;/code&gt; (&lt;code&gt;CPEAAPL&lt;/code&gt; for short). &lt;code&gt;CPEAAPL&lt;/code&gt; is a symbol that is actually an &lt;code&gt;ParenthesizedExpression&lt;/code&gt; or an &lt;code&gt;ArrowParameterList&lt;/code&gt; behind the scenes, but we don&#39;t yet know which one.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://tc39.es/ecma262/#prod-CoverParenthesizedExpressionAndArrowParameterList&quot;&gt;productions&lt;/a&gt; for &lt;code&gt;CPEAAPL&lt;/code&gt; are very permissive, allowing all constructs that can occur in &lt;code&gt;ParenthesizedExpression&lt;/code&gt;s and in &lt;code&gt;ArrowParameterList&lt;/code&gt;s:&lt;/p&gt;
&lt;pre class=&quot;language-grammar&quot;&gt;&lt;code class=&quot;language-grammar&quot;&gt;&lt;span class=&quot;token production-name&quot;&gt;CPEAAPL&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;Expression&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;)&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;Expression&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;)&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;)&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;BindingIdentifier&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;)&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;BindingPattern&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;)&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;Expression&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;BindingIdentifier&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;)&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;Expression&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;BindingPattern&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For example, the following expressions are valid &lt;code&gt;CPEAAPL&lt;/code&gt;s:&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// Valid ParenthesizedExpression and ArrowParameterList:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;// Valid ParenthesizedExpression:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;// Valid ArrowParameterList:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;// Not valid either, but still a CPEAAPL:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Trailing comma and the &lt;code&gt;...&lt;/code&gt; can occur only in &lt;code&gt;ArrowParameterList&lt;/code&gt;. Some constructs, like &lt;code&gt;b = 1&lt;/code&gt; can occur in both, but they have different meanings: Inside &lt;code&gt;ParenthesizedExpression&lt;/code&gt; it&#39;s an assignment, inside &lt;code&gt;ArrowParameterList&lt;/code&gt; it&#39;s a parameter with a default value. Numbers and other &lt;code&gt;PrimaryExpressions&lt;/code&gt; which are not valid parameter names (or parameter destructuring patterns) can only occur in &lt;code&gt;ParenthesizedExpression&lt;/code&gt;. But they all can occur inside a &lt;code&gt;CPEAAPL&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;using-cpeaapl-in-productions&quot;&gt;Using &lt;code&gt;CPEAAPL&lt;/code&gt; in productions &lt;a class=&quot;bookmark&quot; href=&quot;#using-cpeaapl-in-productions&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Now we can use the very permissive &lt;code&gt;CPEAAPL&lt;/code&gt; in &lt;a href=&quot;https://tc39.es/ecma262/#prod-AssignmentExpression&quot;&gt;&lt;code&gt;AssignmentExpression&lt;/code&gt; productions&lt;/a&gt;. (Note: &lt;code&gt;ConditionalExpression&lt;/code&gt; leads to &lt;code&gt;PrimaryExpression&lt;/code&gt; via a long production chain which is not shown here.)&lt;/p&gt;
&lt;pre class=&quot;language-grammar&quot;&gt;&lt;code class=&quot;language-grammar&quot;&gt;&lt;span class=&quot;token production-name&quot;&gt;AssignmentExpression&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;ConditionalExpression&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;ArrowFunction&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token production-name&quot;&gt;ArrowFunction&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;ArrowParameters&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;ConciseBody&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token production-name&quot;&gt;ArrowParameters&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;BindingIdentifier&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;CPEAAPL&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token production-name&quot;&gt;PrimaryExpression&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;...&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;CPEAAPL&lt;/span&gt;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Imagine we&#39;re again in the situation that we need to parse an &lt;code&gt;AssignmentExpression&lt;/code&gt; and the next token is &lt;code&gt;(&lt;/code&gt;. Now we can parse a &lt;code&gt;CPEAAPL&lt;/code&gt; and figure out later what production to use. It doesn&#39;t matter whether we&#39;re parsing an &lt;code&gt;ArrowFunction&lt;/code&gt; or a &lt;code&gt;ConditionalExpression&lt;/code&gt;, the next symbol to parse is &lt;code&gt;CPEAAPL&lt;/code&gt; in any case!&lt;/p&gt;
&lt;p&gt;After we&#39;ve parsed the &lt;code&gt;CPEAAPL&lt;/code&gt;, we can decide which production to use for the original &lt;code&gt;AssignmentExpression&lt;/code&gt; (the one containing the &lt;code&gt;CPEAAPL&lt;/code&gt;). This decision is made based on the token following the &lt;code&gt;CPEAAPL&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If the token is &lt;code&gt;=&amp;gt;&lt;/code&gt;, we use the production:&lt;/p&gt;
&lt;pre class=&quot;language-grammar&quot;&gt;&lt;code class=&quot;language-grammar&quot;&gt;&lt;span class=&quot;token production-name&quot;&gt;AssignmentExpression&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;ArrowFunction&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the token is something else, we use the production:&lt;/p&gt;
&lt;pre class=&quot;language-grammar&quot;&gt;&lt;code class=&quot;language-grammar&quot;&gt;&lt;span class=&quot;token production-name&quot;&gt;AssignmentExpression&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;ConditionalExpression&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; a &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;//      ^^^^^^&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;//     CPEAAPL&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;//             ^^&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;//             The token following the CPEAAPL&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;//      ^^^^^^&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;//     CPEAAPL&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;//            ^&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;//            The token following the CPEAAPL&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At that point we can keep the &lt;code&gt;CPEAAPL&lt;/code&gt; as is and continue parsing the rest of the program. For example, if the &lt;code&gt;CPEAAPL&lt;/code&gt; is inside an &lt;code&gt;ArrowFunction&lt;/code&gt;, we don&#39;t yet need to look at whether it&#39;s a valid arrow function parameter list or not - that can be done later. (Real-world parsers might choose to do the validity check right away, but from the spec point of view, we don&#39;t need to.)&lt;/p&gt;
&lt;h3 id=&quot;restricting-cpeaapls&quot;&gt;Restricting CPEAAPLs &lt;a class=&quot;bookmark&quot; href=&quot;#restricting-cpeaapls&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As we saw before, the grammar productions for &lt;code&gt;CPEAAPL&lt;/code&gt; are very permissive and allow constructs (such as &lt;code&gt;(1, ...a)&lt;/code&gt;) which are never valid. After we&#39;ve done parsing the program according to the grammar, we need to disallow the corresponding illegal constructs.&lt;/p&gt;
&lt;p&gt;The spec does this by adding the following restrictions:&lt;/p&gt;
&lt;div class=&quot;ecmascript-algorithm&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://tc39.es/ecma262/#sec-grouping-operator-static-semantics-early-errors&quot;&gt;Static Semantics: Early Errors&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PrimaryExpression : CPEAAPL&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;It is a Syntax Error if &lt;code&gt;CPEAAPL&lt;/code&gt; is not covering a &lt;code&gt;ParenthesizedExpression&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;ecmascript-algorithm&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://tc39.es/ecma262/#sec-primary-expression&quot;&gt;Supplemental Syntax&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;When processing an instance of the production&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PrimaryExpression : CPEAAPL&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;the interpretation of the &lt;code&gt;CPEAAPL&lt;/code&gt; is refined using the following grammar:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ParenthesizedExpression : ( Expression )&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This means: if a &lt;code&gt;CPEAAPL&lt;/code&gt; occurs in the place of &lt;code&gt;PrimaryExpression&lt;/code&gt; in the syntax tree, it is actually an &lt;code&gt;ParenthesizedExpression&lt;/code&gt; and this is its only valid production.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Expression&lt;/code&gt; can never be empty, so &lt;code&gt;( )&lt;/code&gt; is not a valid &lt;code&gt;ParenthesizedExpression&lt;/code&gt;. Comma separated lists like &lt;code&gt;(1, 2, 3)&lt;/code&gt; are created by &lt;a href=&quot;https://tc39.es/ecma262/#sec-comma-operator&quot;&gt;the comma operator&lt;/a&gt;:&lt;/p&gt;
&lt;pre class=&quot;language-grammar&quot;&gt;&lt;code class=&quot;language-grammar&quot;&gt;&lt;span class=&quot;token production-name&quot;&gt;Expression&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;AssignmentExpression&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;Expression&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;AssignmentExpression&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Similarly, if a &lt;code&gt;CPEAAPL&lt;/code&gt; occurs in the place of &lt;code&gt;ArrowParameters&lt;/code&gt;, the following restrictions apply:&lt;/p&gt;
&lt;div class=&quot;ecmascript-algorithm&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://tc39.es/ecma262/#sec-arrow-function-definitions-static-semantics-early-errors&quot;&gt;Static Semantics: Early Errors&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ArrowParameters : CPEAAPL&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;It is a Syntax Error if &lt;code&gt;CPEAAPL&lt;/code&gt; is not covering an &lt;code&gt;ArrowFormalParameters&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;ecmascript-algorithm&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://tc39.es/ecma262/#sec-arrow-function-definitions&quot;&gt;Supplemental Syntax&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;When the production&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ArrowParameters&lt;/code&gt; : &lt;code&gt;CPEAAPL&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;is recognized the following grammar is used to refine the interpretation of &lt;code&gt;CPEAAPL&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ArrowFormalParameters :&lt;/code&gt;&lt;br&gt;
&lt;code&gt;( UniqueFormalParameters )&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;other-cover-grammars&quot;&gt;Other cover grammars &lt;a class=&quot;bookmark&quot; href=&quot;#other-cover-grammars&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In addition to &lt;code&gt;CPEAAPL&lt;/code&gt;, the spec uses cover grammars for other ambiguous-looking constructs.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ObjectLiteral&lt;/code&gt; is used as a cover grammar for &lt;code&gt;ObjectAssignmentPattern&lt;/code&gt; which occurs inside arrow function parameter lists. This means that &lt;code&gt;ObjectLiteral&lt;/code&gt; allows constructs which cannot occur inside actual object literals.&lt;/p&gt;
&lt;pre class=&quot;language-grammar&quot;&gt;&lt;code class=&quot;language-grammar&quot;&gt;&lt;span class=&quot;token production-name&quot;&gt;ObjectLiteral&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;...&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;PropertyDefinitionList&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token production-name&quot;&gt;PropertyDefinition&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;...&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;CoverInitializedName&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token production-name&quot;&gt;CoverInitializedName&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;IdentifierReference&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;Initializer&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token production-name&quot;&gt;Initializer&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;AssignmentExpression&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; o &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// syntax error&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;// Arrow function with a destructuring parameter with a default&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;// value:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token function&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// returns 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token function&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;a &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// returns 6&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Async arrow functions also look ambiguous with a finite lookahead:&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Is this a call to a function called &lt;code&gt;async&lt;/code&gt; or an async arrow function?&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; x1 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; x2 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;x3&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; x4 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To this end, the grammar defines a cover grammar symbol &lt;code&gt;CoverCallExpressionAndAsyncArrowHead&lt;/code&gt; which works similarly to &lt;code&gt;CPEAAPL&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary &lt;a class=&quot;bookmark&quot; href=&quot;#summary&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In this episode we looked into how the spec defines cover grammars and uses them in cases where we cannot identify the current syntactic construct based on a finite lookahead.&lt;/p&gt;
&lt;p&gt;In particular, we looked into distinguishing arrow function parameter lists from parenthesized expressions and how the spec uses a cover grammar for first parsing ambiguous-looking constructs permissively and restricting them with static semantic rules later.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</content></entry><entry><title>Up to 4GB of memory in WebAssembly</title><link href="https://v8.js.cn/blog/4gb-wasm-memory/"/><updated>2020-05-14T00:00:00-00:00</updated><id>https://v8.js.cn/blog/4gb-wasm-memory/</id><author><name>Andreas Haas, Jakob Kummerow, and Alon Zakai</name></author><content type="html">&lt;h2 id=&quot;introduction&quot;&gt;Introduction &lt;a class=&quot;bookmark&quot; href=&quot;#introduction&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Thanks to recent work in Chrome and Emscripten, you can now use up to 4GB of memory in WebAssembly applications. That’s up from the previous limit of 2GB. It might seem odd that there was ever a limit - after all, no work was needed to allow people to use 512MB or 1GB of memory! - but it turns out that there are some special things happening in the jump from 2GB to 4GB, both in the browser and in the toolchain, which we’ll describe in this post.&lt;/p&gt;
&lt;h2 id=&quot;32-bits&quot;&gt;32 bits &lt;a class=&quot;bookmark&quot; href=&quot;#32-bits&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Some background before we get into more details: the new 4GB limit is the largest amount of memory possible with 32-bit pointers, which is what WebAssembly currently supports, known as “wasm32” in LLVM and elsewhere. There is work towards a “wasm64” (&lt;a href=&quot;https://github.com/WebAssembly/memory64/blob/master/proposals/memory64/Overview.md&quot;&gt;“memory64”&lt;/a&gt; in the wasm spec) in which pointers can be 64-bit and we would be able to make use of over 16 million terabytes of memory (!), but until then, 4GB is the most we can possibly hope to be able to access.&lt;/p&gt;
&lt;p&gt;It seems like we should always have been able to access 4GB, since that’s what 32-bit pointers allow. Why then have we been limited to half that, just 2GB? There are multiple reasons, on both the browser and the toolchain side. Let’s start with the browser.&lt;/p&gt;
&lt;h2 id=&quot;chrome%2Fv8-work&quot;&gt;Chrome/V8 work &lt;a class=&quot;bookmark&quot; href=&quot;#chrome%2Fv8-work&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In principle the changes in V8 sound simple: Just make sure that all code generated for WebAssembly functions, as well as all memory management code, uses unsigned 32-bit integers for memory indices and lengths, and we should be done. However, in practice, there&#39;s more to it than that! As WebAssembly memory can be exported to JavaScript as an ArrayBuffer, we also had to change the implementation of JavaScript ArrayBuffers, TypedArrays, and all Web APIs that use ArrayBuffers and TypedArrays, like Web Audio, WebGPU, and WebUSB.&lt;/p&gt;
&lt;p&gt;The first issue we had to solve was that V8 used &lt;a href=&quot;https://v8.dev/blog/pointer-compression#value-tagging-in-v8&quot;&gt;Smis&lt;/a&gt; (i.e. 31 bit signed integers) for TypedArray indices and lengths, so the maximum size was actually 2&lt;sup&gt;30&lt;/sup&gt;-1, or about 1GB. Additionally, it turns out that switching everything to 32-bit integers would not be enough, because the length of a 4GB memory actually does not fit into a 32-bit integer. To illustrate: in decimal, there are 100 numbers with two digits (0 through 99), but &amp;quot;100&amp;quot; itself is a three-digit number. Analogously, 4GB can be addressed with 32-bit addresses, but 4GB itself is a 33-bit number. We could have settled for a slightly lower limit, but as we had to touch all the TypedArray code anyway, we wanted to prepare it for even bigger future limits while we were at it. So we changed all code that deals with TypedArray indices or lengths to use 64-bit wide integer types, or JavaScript Numbers where interfacing with JavaScript is required. As an added benefit, this means that supporting even larger memories for wasm64 should be relatively straightforward now!&lt;/p&gt;
&lt;p&gt;A second challenge was dealing with JavaScript&#39;s special-casing for Array elements, compared to regular named properties, which is reflected in our implementation of objects. (This is a rather technical issue to do with the JavaScript spec, so don’t worry if you don’t follow all the details.) Consider this example:&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;array&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;5_000_000_000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If &lt;code&gt;array&lt;/code&gt; is a plain JavaScript object or Array, then &lt;code&gt;array[5_000_000_000]&lt;/code&gt; would be handled as a string-based property lookup. The runtime would look for a string-named property “5000000000”. If no such property can be found, it would walk up the prototype chain and look for that property, or eventually return &lt;code&gt;undefined&lt;/code&gt; at the end of the chain. However, if &lt;code&gt;array&lt;/code&gt; itself, or an object on its prototype chain, is a TypedArray, then the runtime must look for an indexed element at the index 5,000,000,000, or immediately return &lt;code&gt;undefined&lt;/code&gt; if this index is out of bounds.&lt;/p&gt;
&lt;p&gt;In other words, the rules for TypedArrays are quite different from normal Arrays, and the difference mostly manifests for huge indices. So as long as we only allowed smaller TypedArrays, our implementation could be relatively simple; in particular, looking at the property key just once was enough to decide whether the &amp;quot;indexed&amp;quot; or the &amp;quot;named&amp;quot; lookup path should be taken. To allow larger TypedArrays, we now have to make this distinction repeatedly as we walk up the prototype chain, which requires careful caching to avoid slowing down existing JavaScript code through repeated work and overhead.&lt;/p&gt;
&lt;h2 id=&quot;toolchain-work&quot;&gt;Toolchain work &lt;a class=&quot;bookmark&quot; href=&quot;#toolchain-work&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;On the toolchain side we had to do work as well, most of it on the JavaScript support code, not the compiled code in WebAssembly. The main issue was that Emscripten has always written memory accesses in this form:&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token constant&quot;&gt;HEAP32&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;ptr &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; offset&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That reads 32 bits (4 bytes) as a signed integer from address &lt;code&gt;ptr + offset&lt;/code&gt;. How this works is that &lt;code&gt;HEAP32&lt;/code&gt; is an Int32Array, which means that each index in the array has 4 bytes. So we need to divide the byte address (&lt;code&gt;ptr + offset&lt;/code&gt;) by 4 to get the index, which is what the &lt;code&gt;&amp;gt;&amp;gt; 2&lt;/code&gt; does.&lt;/p&gt;
&lt;p&gt;The problem is that &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; is a &lt;em&gt;signed&lt;/em&gt; operation! If the address is at the 2GB mark or higher, it will overflow the input into a negative number:&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// Just below 2GB is ok, this prints 536870911&lt;/span&gt;&lt;br&gt;console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1024&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1024&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1024&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;// 2GB overflows and we get -536870912 :(&lt;/span&gt;&lt;br&gt;console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1024&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1024&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The solution is to do an &lt;em&gt;unsigned&lt;/em&gt; shift, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// This gives us 536870912, as we want!&lt;/span&gt;&lt;br&gt;console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1024&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1024&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&gt;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Emscripten knows at compile time whether you may use 2GB or more memory (depending on the flags you use; see later for details). If your flags make 2GB+ addresses possible then the compiler will automatically rewrite all memory accesses to use &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; instead of &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, which includes not just &lt;code&gt;HEAP32&lt;/code&gt; etc. accesses as in the examples above but also operations like &lt;code&gt;.subarray()&lt;/code&gt; and &lt;code&gt;.copyWithin()&lt;/code&gt;. In other words, the compiler will switch to use unsigned pointers instead of signed ones.&lt;/p&gt;
&lt;p&gt;This transformation increases code size a little bit - one extra character in each shift - which is why we don’t do it if you aren’t using 2GB+ addresses. While the difference is typically less than 1%, it’s just unnecessary, and easy to avoid - and lots of small optimizations add up!&lt;/p&gt;
&lt;p&gt;Other rare issues can arise in JavaScript support code. While normal memory accesses are handled automatically as described earlier, doing something like manually comparing a signed pointer to an unsigned one will (on address 2GB and above) return false. To find such issues we’ve audited Emscripten’s JavaScript and also run the test suite in a special mode where everything is placed at address 2GB or higher. (Note that if you write your own JavaScript support code you may have things to fix there as well, if you do manual things with pointers aside from normal memory accesses.)&lt;/p&gt;
&lt;h2 id=&quot;trying-it-out&quot;&gt;Trying it out &lt;a class=&quot;bookmark&quot; href=&quot;#trying-it-out&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To test this, &lt;a href=&quot;https://emscripten.org/docs/getting_started/downloads.html&quot;&gt;get the latest Emscripten release&lt;/a&gt;, or at least version 1.39.15. Then build with flags such as&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;emcc -s ALLOW_MEMORY_GROWTH -s MAXIMUM_MEMORY=4GB
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Those enable memory growth, and allow the program to allocate all the way up to 4GB of memory. Note that by default you will only be able to allocate up to 2GB - you must explicitly opt in to using 2-4GB (this allows us to emit more compact code otherwise, by emitting &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; instead of &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; as mentioned above).&lt;/p&gt;
&lt;p&gt;Make sure to test on Chrome M83 (currently in Beta) or later. Please file issues if you find anything wrong!&lt;/p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion &lt;a class=&quot;bookmark&quot; href=&quot;#conclusion&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Support for up to 4GB memory is another step in making the web as capable as native platforms, allowing 32-bit programs to be able to use just as much memory as they would normally. By itself this doesn’t enable a completely new class of application, but it does enable higher-end experiences, such as a very large level in a game or manipulating large content in a graphical editor.&lt;/p&gt;
&lt;p&gt;As mentioned earlier, support for 64-bit memory is also planned, which will allow accessing even more than 4GB. However, wasm64 will have the same downside as 64-bit does on native platforms, that pointers take twice as much memory. That’s why 4GB support in wasm32 is so important: We can access twice as much memory as before while code size remains as compact as wasm has always been!&lt;/p&gt;
&lt;p&gt;As always, test your code on multiple browsers, and also remember that 2-4GB is a lot of memory! If you need that much you should use it, but don’t do so unnecessarily since there just won’t be enough free memory on many users’ machines. We recommend that you start with an initial memory that is as small as possible, and grow if necessary; and if you allow growth, gracefully handle the case of a &lt;code&gt;malloc()&lt;/code&gt; failure.&lt;/p&gt;
</content></entry><entry><title>V8 release v8.3</title><link href="https://v8.js.cn/blog/v8-release-83/"/><updated>2020-05-04T00:00:00-00:00</updated><id>https://v8.js.cn/blog/v8-release-83/</id><author><name>Victor Gomes, safely working from home</name></author><content type="html">&lt;p&gt;Every six weeks, we create a new branch of V8 as part of our &lt;a href=&quot;https://v8.dev/docs/release-process&quot;&gt;release process&lt;/a&gt;. Each version is branched from V8’s Git master immediately before a Chrome Beta milestone. Today we’re pleased to announce our newest branch, &lt;a href=&quot;https://chromium.googlesource.com/v8/v8.git/+log/branch-heads/8.3&quot;&gt;V8 version 8.3&lt;/a&gt;, which is in beta until its release in coordination with Chrome 83 Stable in several weeks. V8 v8.3 is filled with all sorts of developer-facing goodies. This post provides a preview of some of the highlights in anticipation of the release.&lt;/p&gt;
&lt;h2 id=&quot;performance&quot;&gt;Performance &lt;a class=&quot;bookmark&quot; href=&quot;#performance&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&quot;faster-arraybuffer-tracking-in-the-garbage-collector&quot;&gt;Faster &lt;code&gt;ArrayBuffer&lt;/code&gt; tracking in the garbage collector &lt;a class=&quot;bookmark&quot; href=&quot;#faster-arraybuffer-tracking-in-the-garbage-collector&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Backing stores of &lt;code&gt;ArrayBuffer&lt;/code&gt;s are allocated outside V8’s heap using  &lt;code&gt;ArrayBuffer::Allocator&lt;/code&gt; provided by the embedder. These backing stores need to be released when their &lt;code&gt;ArrayBuffer&lt;/code&gt; object is reclaimed by the garbage collector. V8 v8.3 has a new mechanism for tracking &lt;code&gt;ArrayBuffer&lt;/code&gt;s and their backing stores that allows the garbage collector to iterate and free the backing store concurrently to the application. More details are available in &lt;a href=&quot;https://docs.google.com/document/d/1-ZrLdlFX1nXT3z-FAgLbKal1gI8Auiaya_My-a0UJ28/edit#heading=h.gfz6mi5p212e&quot;&gt;this design document&lt;/a&gt;. This reduced total GC pause time in &lt;code&gt;ArrayBuffer&lt;/code&gt; heavy workloads by 50%.&lt;/p&gt;
&lt;h3 id=&quot;bigger-wasm-memories&quot;&gt;Bigger Wasm memories &lt;a class=&quot;bookmark&quot; href=&quot;#bigger-wasm-memories&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In accordance with an update to the &lt;a href=&quot;https://webassembly.github.io/spec/js-api/index.html#limits&quot;&gt;WebAssembly specification&lt;/a&gt;, V8 v8.3 now allows modules to request memories up to 4GB in size, allowing more memory-heavy use cases to be brought to platforms powered by V8. Please keep in mind that this much memory might not always be available on a user’s system; we recommend creating memories at smaller sizes, growing them as needed, and gracefully handling failures to grow.&lt;/p&gt;
&lt;h2 id=&quot;fixes&quot;&gt;Fixes &lt;a class=&quot;bookmark&quot; href=&quot;#fixes&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&quot;stores-to-objects-with-typed-arrays-on-the-prototype-chain&quot;&gt;Stores to objects with typed arrays on the prototype chain &lt;a class=&quot;bookmark&quot; href=&quot;#stores-to-objects-with-typed-arrays-on-the-prototype-chain&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;According to the JavaScript specification, when storing a value to the specified key we need to lookup the prototype chain to see if the key already exists on the prototype. More often than not these keys don’t exist on the prototype chain, and so V8 installs fast lookup handlers to avoid these prototype chain walks when it is safe to do so.&lt;/p&gt;
&lt;p&gt;However, we recently identified a particular scenario where V8 incorrectly installed this fast lookup handler, leading to incorrect behaviour. When &lt;code&gt;TypedArray&lt;/code&gt;s are on the prototype chain, all stores to keys which are OOB of the &lt;code&gt;TypedArray&lt;/code&gt; should be ignored. For example, in the case below &lt;code&gt;v[2]&lt;/code&gt; shouldn’t add a property to &lt;code&gt;v&lt;/code&gt; and the subsequent reads should return undefined.&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;v &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;v&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;__proto__ &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Int32Array&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;v&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; v&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Should return undefined&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;V8’s fast lookup handlers don’t handle this case, and we would instead return &lt;code&gt;123&lt;/code&gt; in the above example. V8 v8.3 fixes this issue by not using fast lookup handlers when &lt;code&gt;TypedArray&lt;/code&gt;s are on the prototype chain. Given that this isn’t a common case, we haven’t seen any performance regression on our benchmarks.&lt;/p&gt;
&lt;h2 id=&quot;v8-api&quot;&gt;V8 API &lt;a class=&quot;bookmark&quot; href=&quot;#v8-api&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&quot;experimental-weakrefs-and-finalizationregistry-apis-deprecated&quot;&gt;Experimental WeakRefs and FinalizationRegistry APIs deprecated &lt;a class=&quot;bookmark&quot; href=&quot;#experimental-weakrefs-and-finalizationregistry-apis-deprecated&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The following experimental WeakRefs-related APIs are deprecated:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;v8::FinalizationGroup&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;v8::Isolate::SetHostCleanupFinalizationGroupCallback&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;FinalizationRegistry&lt;/code&gt; (renamed from &lt;code&gt;FinalizationGroup&lt;/code&gt;) is part of the &lt;a href=&quot;https://v8.dev/features/weak-references&quot;&gt;JavaScript weak references proposal&lt;/a&gt; and provides a way for JavaScript programmers to register finalizers. These APIs are for the embedder to schedule and run &lt;code&gt;FinalizationRegistry&lt;/code&gt; cleanup tasks where the registered finalizers are invoked; they are deprecated because they are no longer needed. &lt;code&gt;FinalizationRegistry&lt;/code&gt; cleanup tasks are now scheduled automatically by V8 using the foreground task runner provided by the embedder’s &lt;code&gt;v8::Platform&lt;/code&gt; and do not require any additional embedder code.&lt;/p&gt;
&lt;h3 id=&quot;other-api-changes&quot;&gt;Other API changes &lt;a class=&quot;bookmark&quot; href=&quot;#other-api-changes&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Please use &lt;code&gt;git log branch-heads/8.1..branch-heads/8.3 include/v8.h&lt;/code&gt; to get a list of the API changes.&lt;/p&gt;
&lt;p&gt;Developers with an active V8 checkout can use &lt;code&gt;git checkout -b 8.3 -t branch-heads/8.3&lt;/code&gt; to experiment with the new features in V8 v8.3. Alternatively you can &lt;a href=&quot;https://www.google.com/chrome/browser/beta.html&quot;&gt;subscribe to Chrome’s Beta channel&lt;/a&gt; and try the new features out yourself soon.&lt;/p&gt;
</content></entry><entry><title>.wasm 是什么？wasm 反编译简介</title><link href="https://v8.js.cn/blog/wasm-decompile/"/><updated>2020-04-27T00:00:00-00:00</updated><id>https://v8.js.cn/blog/wasm-decompile/</id><author><name>Wouter van Oortmerssen (@wvo)</name></author><content type="html">&lt;p&gt;我们有越来越多的生成或操作 &lt;code&gt;.wasm&lt;/code&gt; 文件的编译器和其他工具，有时你可能想看看里面。也许您是这种工具的开发人员，或更直接地，您是 &lt;code&gt;Wasm&lt;/code&gt; 程序员，并且出于性能或其他原因，想知道生成的代码是什么样的。&lt;/p&gt;
&lt;p&gt;问题是，Wasm相当底层，很像实际的汇编代码。特别是，与JVM不同，所有数据结构都编译成加载/存储操作，而不是方便地命名类和字段。诸如LLVM之类的编译器可以进行大量的转换，使生成的代码看起来像输入的代码一样。&lt;/p&gt;
&lt;h2 id=&quot;disassemble-or-decompile&quot;&gt;反汇编还是..反编译？ &lt;a class=&quot;bookmark&quot; href=&quot;#disassemble-or-decompile&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;您可以使用 &lt;code&gt;wasm2wat&lt;/code&gt;（&lt;a href=&quot;https://github.com/WebAssembly/wabt&quot;&gt;WABT&lt;/a&gt; 工具包的一部分）之类的工具，将 &lt;code&gt;.wasm&lt;/code&gt; 转换为 Wasm 的标准文本格式 &lt;code&gt;.wat&lt;/code&gt;，是非常忠实但不是特别可读的表示形式。&lt;/p&gt;
&lt;p&gt;例如，一个简单的计算点积的 C 函数：&lt;/p&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;float&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; z&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; vec3&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;dot&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; vec3 &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; vec3 &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; a&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;x &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; b&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;x &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;&lt;br&gt;           a&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;y &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; b&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;y &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;&lt;br&gt;           a&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;z &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; b&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;z&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们使用 &lt;code&gt;clang dot.c -c -target wasm32 -O2&lt;/code&gt;，然后使用 &lt;code&gt;wasm2wat -f dot.o&lt;/code&gt; 将其转换为下面这个 &lt;code&gt;.wat&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;language-wasm&quot;&gt;&lt;code class=&quot;language-wasm&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$dot&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;param&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;f32&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;f32&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;add&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;f32&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;add&lt;/span&gt;&lt;br&gt;      &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;f32&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;mul&lt;/span&gt;&lt;br&gt;        &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;f32&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;load&lt;/span&gt;&lt;br&gt;          &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;local&lt;/span&gt;.get &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br&gt;        &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;f32&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;load&lt;/span&gt;&lt;br&gt;          &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;local&lt;/span&gt;.get &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br&gt;      &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;f32&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;mul&lt;/span&gt;&lt;br&gt;        &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;f32&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;load&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;offset&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;br&gt;          &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;local&lt;/span&gt;.get &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br&gt;        &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;f32&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;load&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;offset&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;br&gt;          &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;local&lt;/span&gt;.get &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;f32&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;mul&lt;/span&gt;&lt;br&gt;      &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;f32&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;load&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;offset&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;8&lt;/span&gt;&lt;br&gt;        &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;local&lt;/span&gt;.get &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br&gt;      &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;f32&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;load&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;offset&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;8&lt;/span&gt;&lt;br&gt;        &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;local&lt;/span&gt;.get &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那只是一小段代码，但是由于许多原因，阅读起来并不好。除了缺乏基于表达式的语法和冗长之外，还不容易让人理解的内存中的数据结构。现在想象一下如果是大型程序的输出，很容易让人崩溃。&lt;/p&gt;
&lt;p&gt;如果替代 &lt;code&gt;wasm2wat&lt;/code&gt;，运行 &lt;code&gt;wasm-decompile dot.o&lt;/code&gt;，您将得到：&lt;/p&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;function &lt;span class=&quot;token function&quot;&gt;dot&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; a&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; c&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br&gt;             b&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; a&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; c&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;a &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;a &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;b &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;b &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;c &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;c&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这看起来要熟悉得多。除了模仿你熟悉的基于表达式语法的编程语言的外，反编译器还会查看函数中的所有加载和存储的数据，并尝试推断其结构。然后，它给每个用作指针的变量添加“内联”的结构声明。它不会创建命名的结构体声明，因为它不一定知道3个浮点数的哪种用法代表相同的概念。&lt;/p&gt;
&lt;h2 id=&quot;decompile-to-what&quot;&gt;反编译成什么？ &lt;a class=&quot;bookmark&quot; href=&quot;#decompile-to-what&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;wasm-decompile&lt;/code&gt; 的输出结果尽可能看起来像“非常普通的编程语言”，但仍十分接近 Wasm 的表达。&lt;/p&gt;
&lt;p&gt;它的目标第一是可读性：尽可能用易于理解的代码帮助读者理解 &lt;code&gt;.wasm&lt;/code&gt; 中的内容。其次是尽可能 1:1 表示 Wasm，以避免失去它作为反汇编程序的实用性。显然，这两个目标并不总是统一的。&lt;/p&gt;
&lt;p&gt;这个输出并不意味着是一种实际的编程语言，并且目前无法将其编译回 Wasm。&lt;/p&gt;
&lt;h3 id=&quot;loads-and-stores&quot;&gt;加载和存储 &lt;a class=&quot;bookmark&quot; href=&quot;#loads-and-stores&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;如上所示，&lt;code&gt;wasm-decompile&lt;/code&gt; 会查看特定指针上的所有加载和存储。如果它们形成一个连续的访问集，它将输出这些“内联”结构声明之一。&lt;/p&gt;
&lt;p&gt;如果不是所有“字段”都被访问，则无法确定这是固定结构，还是其他无关的内存访问形式。在这种情况下，它会退回到更简单的类型，例如 &lt;code&gt;float_ptr&lt;/code&gt;（如果类型相同），在最坏的情况下，会输出一个类似 &lt;code&gt;o[2]：int&lt;/code&gt; 的数组访问，其中 &lt;code&gt;o&lt;/code&gt; 指向 &lt;code&gt;int&lt;/code&gt; 值，我们正在访问第三个值。&lt;/p&gt;
&lt;p&gt;最后一种情况发生的频率比你想象的要多，因为 Wasm 局部变量的功能更像寄存器而不是变量，因此优化的代码可能会为不相关的对象共享同一个指针。&lt;/p&gt;
&lt;p&gt;反编译器尝试在索引方面更加聪明，并检测诸如 &lt;code&gt;(base + (index &amp;lt;&amp;lt; 2))[0]:int&lt;/code&gt; 之类的模式，这些模式是由常规的 C 数组索引操作（如 &lt;code&gt;base[index]&lt;/code&gt; 其中 &lt;code&gt;base&lt;/code&gt; 指向4字节类型）导致的。这些在代码中非常常见，因为 Wasm 在加载和存储上只有恒定的偏移量。&lt;code&gt;wasm-decompile&lt;/code&gt; 的输出结果会将它们转换回 &lt;code&gt;base[index]:int&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;此外，它还知道绝对地址何时引用数据段。&lt;/p&gt;
&lt;h3 id=&quot;control-flow&quot;&gt;控制流程 &lt;a class=&quot;bookmark&quot; href=&quot;#control-flow&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;最常见的是Wasm的if-then结构，它翻译成一个熟悉的 &lt;code&gt;if (cond) { A } else { B }&lt;/code&gt; 语法，另外在 Wasm 中它实际上可以返回一个值，所以它也可以表示成在某些语言中像这样的三元语法 &lt;code&gt;cond ? A : B&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Wasm 其余的控制流基于 &lt;code&gt;block&lt;/code&gt; 和 &lt;code&gt;loop&lt;/code&gt; 块，以及 &lt;code&gt;br&lt;/code&gt;、&lt;code&gt;br_if&lt;/code&gt; 和 &lt;code&gt;br_table&lt;/code&gt; 跳转。反编译器会适当地接近这样的结构，而不是试图推断它们可能来自 while/for/switch 的结构，因为这样可以更好地处理优化后的输出。例如，&lt;code&gt;wasm-decompile&lt;/code&gt; 输出中典型的循环可能如下所示：&lt;/p&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;loop A &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token comment&quot;&gt;// body of the loop here.&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cond&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;continue&lt;/span&gt; A&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里，&lt;code&gt;A&lt;/code&gt; 是一个标签，允许嵌套多个。与 while 循环相比，使用 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;continue&lt;/code&gt; 来控制循环可能看起来有点陌生，但它直接对应于 Wasm 的 &lt;code&gt;br_if&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;block&lt;/code&gt; 类似，但它们不是向后分支，而是向前分支：&lt;/p&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;block &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cond&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token comment&quot;&gt;// body goes here.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这实际上实现了 &lt;code&gt;if-then&lt;/code&gt;。如果可能的话，未来版本的反编译器可能会将这些代码转换为实际版本。&lt;/p&gt;
&lt;p&gt;Wasm 最令人惊讶的控制结构是 &lt;code&gt;br_table&lt;/code&gt;，它实现了类似 &lt;code&gt;switch&lt;/code&gt; 的功能，但使用了嵌套的 &lt;code&gt;block&lt;/code&gt;，这往往很难读取。反编译器会将这些 &lt;code&gt;block&lt;/code&gt; 展平以使它们更容易理解，例如：&lt;/p&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;br_table&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;A&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; B&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; C&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;D&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;label A&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;label B&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;label C&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;label D&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这类似于 &lt;code&gt;switch(a)&lt;/code&gt; 默认返回 &lt;code&gt;D&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;other-fun-features&quot;&gt;其他有趣的功能 &lt;a class=&quot;bookmark&quot; href=&quot;#other-fun-features&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;反编译器:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以从调试或链接信息中提取名称，或生成名称本身。当使用现有名称时，它有特殊的代码来简化C++名称中混乱的符号。&lt;/li&gt;
&lt;li&gt;已经支持多值提案，这使得表达式和语句的转化有点困难。当返回多个值时，将使用其他变量。&lt;/li&gt;
&lt;li&gt;它甚至可以从数据段的 &lt;em&gt;contents&lt;/em&gt; 生成名称&lt;/li&gt;
&lt;li&gt;输出所有 Wasm section 类型的漂亮声明，而不仅仅是代码。例如，通过文本输出，使其成为可能。&lt;/li&gt;
&lt;li&gt;支持运算符优先级（大多数类 C 语言通用）以减少公共表达式上的 &lt;code&gt;()&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;limitations&quot;&gt;局限性 &lt;a class=&quot;bookmark&quot; href=&quot;#limitations&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;反编译 Wasm 比JVM字节码更难。&lt;/p&gt;
&lt;p&gt;后者是未优化的，因此相对忠于原始代码的结构，即使名称可能丢失，也引用了唯一的类，而不仅仅是内存位置。&lt;/p&gt;
&lt;p&gt;相比之下，大多数 &lt;code&gt;.wasm&lt;/code&gt; 的输出都经过了 LLVM 的大量优化，因此常常会丢失其大部分原始结构。输出代码与程序员编写的代码非常不同。这使得 Wasm 反编译器将会是一个更大的挑战，但这并不意味着我们不应该尝试！&lt;/p&gt;
&lt;h2 id=&quot;more&quot;&gt;更多内容 &lt;a class=&quot;bookmark&quot; href=&quot;#more&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;当然，最好的方法是反编译您自己的 Wasm 项目！&lt;/p&gt;
&lt;p&gt;此外，关于 &lt;code&gt;wasm-decompile&lt;/code&gt; 的更深入的指南，&lt;a href=&quot;https://github.com/WebAssembly/wabt/blob/master/docs/decompiler.md&quot;&gt;链接&lt;/a&gt;。它的实现在源文件中以 &lt;code&gt;decompiler&lt;/code&gt; 开头，&lt;a href=&quot;https://github.com/WebAssembly/wabt/tree/master/src&quot;&gt;链接&lt;/a&gt;（欢迎提PR，使它变得更好）。一些测试用例展示了 &lt;code&gt;.wat&lt;/code&gt; 和反编译器之间差异的更多示例，&lt;a href=&quot;https://github.com/WebAssembly/wabt/tree/master/test/decompile&quot;&gt;链接&lt;/a&gt;.&lt;/p&gt;
</content></entry><entry><title>Understanding the ECMAScript spec, part 3</title><link href="https://v8.js.cn/blog/understanding-ecmascript-part-3/"/><updated>2020-04-01T00:00:00-00:00</updated><id>https://v8.js.cn/blog/understanding-ecmascript-part-3/</id><author><name>Marja Hölttä, speculative specification spectator</name></author><content type="html">&lt;p&gt;…where we dive deep in the syntax!&lt;/p&gt;
&lt;h2 id=&quot;previous-episodes&quot;&gt;Previous episodes &lt;a class=&quot;bookmark&quot; href=&quot;#previous-episodes&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In &lt;a href=&quot;https://v8.js.cn/blog/understanding-ecmascript-part-1&quot;&gt;part 1&lt;/a&gt;, we read through a simple method — &lt;code&gt;Object.prototype.hasOwnProperty&lt;/code&gt; — and the &lt;strong&gt;abstract operations&lt;/strong&gt; it invokes. We familiarized ourselves with the shorthands &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;!&lt;/code&gt; related to error handling. We encountered &lt;strong&gt;language types&lt;/strong&gt;, &lt;strong&gt;specification types&lt;/strong&gt;, &lt;strong&gt;internal slots&lt;/strong&gt;, and &lt;strong&gt;internal methods&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;In &lt;a href=&quot;https://v8.js.cn/blog/understanding-ecmascript-part-2&quot;&gt;part 2&lt;/a&gt;, we examined a simple grammar production and how its runtime semantics are defined. In &lt;a href=&quot;https://v8.js.cn/blog/extra/understanding-ecmascript-part-2-extra&quot;&gt;the extra content&lt;/a&gt;, we also followed a long grammar production chain from &lt;code&gt;AssignmentExpression&lt;/code&gt; to &lt;code&gt;MemberExpression&lt;/code&gt;. In this episode, we’ll go deeper in the definition of the ECMAScript language and its syntax.&lt;/p&gt;
&lt;p&gt;If you’re not familiar with &lt;a href=&quot;https://en.wikipedia.org/wiki/Context-free_grammar&quot;&gt;context-free grammars&lt;/a&gt;, now is a good time to check out the basics, since the spec uses context-free grammars to define the language.&lt;/p&gt;
&lt;h2 id=&quot;ecmascript-grammars&quot;&gt;ECMAScript grammars &lt;a class=&quot;bookmark&quot; href=&quot;#ecmascript-grammars&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The ECMAScript spec defines four grammars:&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://tc39.es/ecma262/#sec-ecmascript-language-lexical-grammar&quot;&gt;lexical grammar&lt;/a&gt; describes how &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode#Architecture_and_terminology&quot;&gt;Unicode code points&lt;/a&gt; are translated into a sequence of &lt;strong&gt;input elements&lt;/strong&gt; (tokens, line terminators, comments, white space).&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://tc39.es/ecma262/#sec-syntactic-grammar&quot;&gt;syntactic grammar&lt;/a&gt; defines how syntactically correct programs are composed of tokens.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://tc39.es/ecma262/#sec-patterns&quot;&gt;RegExp grammar&lt;/a&gt; describes how Unicode code points are translated into regular expressions.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://tc39.es/ecma262/#sec-tonumber-applied-to-the-string-type&quot;&gt;numeric string grammar&lt;/a&gt; describes how Strings are translated into numeric values.&lt;/p&gt;
&lt;p&gt;Each grammar is defined as a context-free grammar, consisting of a set of productions.&lt;/p&gt;
&lt;p&gt;The grammars use slightly different notation: the syntactic grammar uses &lt;code&gt;LeftHandSideSymbol :&lt;/code&gt; whereas the lexical grammar and the RegExp grammar use &lt;code&gt;LeftHandSideSymbol ::&lt;/code&gt; and the numeric string grammar uses &lt;code&gt;LeftHandSideSymbol :::&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Next we’ll look into the lexical grammar and the syntactic grammar in more detail.&lt;/p&gt;
&lt;h2 id=&quot;lexical-grammar&quot;&gt;Lexical grammar &lt;a class=&quot;bookmark&quot; href=&quot;#lexical-grammar&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The spec defines ECMAScript source text as a sequence of Unicode code points. For example, variable names are not limited to ASCII characters but can also include other Unicode characters. The spec doesn’t talk about the actual encoding (for example, UTF-8 or UTF-16). It assumes that the source code has already been converted into a sequence of Unicode code points according to the encoding it was in.&lt;/p&gt;
&lt;p&gt;It’s not possible to tokenize ECMAScript source code in advance, which makes defining the lexical grammar slightly more complicated.&lt;/p&gt;
&lt;p&gt;For example, we cannot determine whether &lt;code&gt;/&lt;/code&gt; is the division operator or the start of a RegExp without looking at the larger context it occurs in:&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here &lt;code&gt;/&lt;/code&gt; is a &lt;code&gt;DivPunctuator&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; r &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token regex&quot;&gt;/foo/&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here the first &lt;code&gt;/&lt;/code&gt; is the start of a &lt;code&gt;RegularExpressionLiteral&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Templates introduce a similar ambiguity — the interpretation of &lt;code&gt;}`&lt;/code&gt; depends on the context it occurs in:&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; what1 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;temp&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; what2 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;late&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; t &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;I am a &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt; what1 &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; what2 &lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here &lt;code&gt;`I am a ${&lt;/code&gt; is &lt;code&gt;TemplateHead&lt;/code&gt; and &lt;code&gt;}`&lt;/code&gt; is a &lt;code&gt;TemplateTail&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;not very useful&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here &lt;code&gt;}&lt;/code&gt; is a &lt;code&gt;RightBracePunctuator&lt;/code&gt; and &lt;code&gt;`&lt;/code&gt; is the start of a &lt;code&gt;NoSubstitutionTemplate&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Even though the interpretation of &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;}`&lt;/code&gt; depends on their “context” — their position in the syntactic structure of the code — the grammars we’ll describe next are still context-free.&lt;/p&gt;
&lt;p&gt;The lexical grammar uses several goal symbols to distinguish between the contexts where some input elements are permitted and some are not. For example, the goal symbol &lt;code&gt;InputElementDiv&lt;/code&gt; is used in contexts where &lt;code&gt;/&lt;/code&gt; is a division and &lt;code&gt;/=&lt;/code&gt; is a division-assignment. The &lt;a href=&quot;https://tc39.es/ecma262/#prod-InputElementDiv&quot;&gt;&lt;code&gt;InputElementDiv&lt;/code&gt;&lt;/a&gt; productions list the possible tokens which can be produced in this context:&lt;/p&gt;
&lt;pre class=&quot;language-grammar&quot;&gt;&lt;code class=&quot;language-grammar&quot;&gt;&lt;span class=&quot;token production-name&quot;&gt;InputElementDiv&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;::&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;WhiteSpace&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;LineTerminator&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;Comment&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;CommonToken&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;DivPunctuator&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;RightBracePunctuator&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this context, encountering &lt;code&gt;/&lt;/code&gt; produces the &lt;code&gt;DivPunctuator&lt;/code&gt; input element. Producing a &lt;code&gt;RegularExpressionLiteral&lt;/code&gt; is not an option here.&lt;/p&gt;
&lt;p&gt;On the other hand, &lt;a href=&quot;https://tc39.es/ecma262/#prod-InputElementRegExp&quot;&gt;&lt;code&gt;InputElementRegExp&lt;/code&gt;&lt;/a&gt; is the goal symbol for the contexts where &lt;code&gt;/&lt;/code&gt; is the beginning of a RegExp:&lt;/p&gt;
&lt;pre class=&quot;language-grammar&quot;&gt;&lt;code class=&quot;language-grammar&quot;&gt;&lt;span class=&quot;token production-name&quot;&gt;InputElementRegExp&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;::&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;WhiteSpace&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;LineTerminator&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;Comment&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;CommonToken&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;RightBracePunctuator&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;RegularExpressionLiteral&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As we see from the productions, it’s possible that this produces the &lt;code&gt;RegularExpressionLiteral&lt;/code&gt; input element, but producing &lt;code&gt;DivPunctuator&lt;/code&gt; is not possible.&lt;/p&gt;
&lt;p&gt;Similarly, there is another goal symbol, &lt;code&gt;InputElementRegExpOrTemplateTail&lt;/code&gt;, for contexts where &lt;code&gt;TemplateMiddle&lt;/code&gt; and &lt;code&gt;TemplateTail&lt;/code&gt; are permitted, in addition to &lt;code&gt;RegularExpressionLiteral&lt;/code&gt;. And finally, &lt;code&gt;InputElementTemplateTail&lt;/code&gt; is the goal symbol for contexts where only &lt;code&gt;TemplateMiddle&lt;/code&gt; and &lt;code&gt;TemplateTail&lt;/code&gt; are permitted but &lt;code&gt;RegularExpressionLiteral&lt;/code&gt; is not permitted.&lt;/p&gt;
&lt;p&gt;In implementations, the syntactic grammar analyzer (“parser”) may call the lexical grammar analyzer (“tokenizer” or “lexer”), passing the goal symbol as a parameter and asking for the next input element suitable for that goal symbol.&lt;/p&gt;
&lt;h2 id=&quot;syntactic-grammar&quot;&gt;Syntactic grammar &lt;a class=&quot;bookmark&quot; href=&quot;#syntactic-grammar&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We looked into the lexical grammar, which defines how we construct tokens from Unicode code points. The syntactic grammar builds on it: it defines how syntactically correct programs are composed of tokens.&lt;/p&gt;
&lt;h3 id=&quot;example%3A-allowing-legacy-identifiers&quot;&gt;Example: Allowing legacy identifiers &lt;a class=&quot;bookmark&quot; href=&quot;#example%3A-allowing-legacy-identifiers&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Introducing a new keyword to the grammar is a possibly breaking change — what if existing code already uses the keyword as an identifier?&lt;/p&gt;
&lt;p&gt;For example, before &lt;code&gt;await&lt;/code&gt; was a keyword, someone might have written the following code:&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;old&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The ECMAScript grammar carefully added the &lt;code&gt;await&lt;/code&gt; keyword in such a way that this code continues to work. Inside async functions, &lt;code&gt;await&lt;/code&gt; is a keyword, so this doesn’t work:&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;modern&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Syntax error&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Allowing &lt;code&gt;yield&lt;/code&gt; as an identifier in non-generators and disallowing it in generators works similarly.&lt;/p&gt;
&lt;p&gt;Understanding how &lt;code&gt;await&lt;/code&gt; is allowed as an identifier requires understanding ECMAScript-specific syntactic grammar notation. Let’s dive right in!&lt;/p&gt;
&lt;h3 id=&quot;productions-and-shorthands&quot;&gt;Productions and shorthands &lt;a class=&quot;bookmark&quot; href=&quot;#productions-and-shorthands&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Let’s look at how the productions for &lt;a href=&quot;https://tc39.es/ecma262/#prod-VariableStatement&quot;&gt;&lt;code&gt;VariableStatement&lt;/code&gt;&lt;/a&gt; are defined. At the first glance, the grammar can look a bit scary:&lt;/p&gt;
&lt;pre class=&quot;language-grammar&quot;&gt;&lt;code class=&quot;language-grammar&quot;&gt;&lt;span class=&quot;token production-name&quot;&gt;VariableStatement&lt;/span&gt;&lt;span class=&quot;token production-params&quot;&gt;[Yield, Await]&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;VariableDeclarationList&lt;/span&gt;&lt;span class=&quot;token production-params&quot;&gt;[+In, ?Yield, ?Await]&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What do the subscripts (&lt;code&gt;[Yield, Await]&lt;/code&gt;) and prefixes (&lt;code&gt;+&lt;/code&gt; in &lt;code&gt;+In&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt; in &lt;code&gt;?Async&lt;/code&gt;) mean?&lt;/p&gt;
&lt;p&gt;The notation is explained in the section &lt;a href=&quot;https://tc39.es/ecma262/#sec-grammar-notation&quot;&gt;Grammar Notation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The subscripts are a shorthand for expressing a set of productions, for a set of left-hand side symbols, all at once. The left-hand side symbol has two parameters, which expands into four &amp;quot;real&amp;quot; left-hand side symbols: &lt;code&gt;VariableStatement&lt;/code&gt;, &lt;code&gt;VariableStatement_Yield&lt;/code&gt;, &lt;code&gt;VariableStatement_Await&lt;/code&gt;, and &lt;code&gt;VariableStatement_Yield_Await&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note that here the plain &lt;code&gt;VariableStatement&lt;/code&gt; means “&lt;code&gt;VariableStatement&lt;/code&gt; without &lt;code&gt;_Await&lt;/code&gt; and &lt;code&gt;_Yield&lt;/code&gt;”. It should not be confused with &lt;code&gt;VariableStatement&lt;sub&gt;[Yield, Await]&lt;/sub&gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;On the right-hand side of the production, we see the shorthand &lt;code&gt;+In&lt;/code&gt;, meaning &amp;quot;use the version with &lt;code&gt;_In&lt;/code&gt;&amp;quot;, and &lt;code&gt;?Await&lt;/code&gt;, meaning “use the version with &lt;code&gt;_Await&lt;/code&gt; if and only if the left-hand side symbol has &lt;code&gt;_Await&lt;/code&gt;” (similarly with &lt;code&gt;?Yield&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;The third shorthand, &lt;code&gt;~Foo&lt;/code&gt;, meaning “use the version without &lt;code&gt;_Foo&lt;/code&gt;”, is not used in this production.&lt;/p&gt;
&lt;p&gt;With this information, we can expand the productions like this:&lt;/p&gt;
&lt;pre class=&quot;language-grammar&quot;&gt;&lt;code class=&quot;language-grammar&quot;&gt;&lt;span class=&quot;token production-name&quot;&gt;VariableStatement&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;VariableDeclarationList_In&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token production-name&quot;&gt;VariableStatement_Yield&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;VariableDeclarationList_In_Yield&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token production-name&quot;&gt;VariableStatement_Await&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;VariableDeclarationList_In_Await&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token production-name&quot;&gt;VariableStatement_Yield_Await&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;VariableDeclarationList_In_Yield_Await&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ultimately, we need to find out two things:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Where is it decided whether we’re in the case with &lt;code&gt;_Await&lt;/code&gt; or without &lt;code&gt;_Await&lt;/code&gt;?&lt;/li&gt;
&lt;li&gt;Where does it make a difference — where do the productions for &lt;code&gt;Something_Await&lt;/code&gt; and &lt;code&gt;Something&lt;/code&gt; (without &lt;code&gt;_Await&lt;/code&gt;) diverge?&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;_await-or-no-_await%3F&quot;&gt;&lt;code&gt;_Await&lt;/code&gt; or no &lt;code&gt;_Await&lt;/code&gt;? &lt;a class=&quot;bookmark&quot; href=&quot;#_await-or-no-_await%3F&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Let’s tackle question 1 first. It’s somewhat easy to guess that non-async functions and async functions differ in whether we pick the parameter &lt;code&gt;_Await&lt;/code&gt; for the function body or not. Reading the productions for async function declarations, we find &lt;a href=&quot;https://tc39.es/ecma262/#prod-AsyncFunctionBody&quot;&gt;this&lt;/a&gt;:&lt;/p&gt;
&lt;pre class=&quot;language-grammar&quot;&gt;&lt;code class=&quot;language-grammar&quot;&gt;&lt;span class=&quot;token production-name&quot;&gt;AsyncFunctionBody&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;FunctionBody&lt;/span&gt;&lt;span class=&quot;token production-params&quot;&gt;[~Yield, +Await]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that &lt;code&gt;AsyncFunctionBody&lt;/code&gt; has no parameters — they get added to the &lt;code&gt;FunctionBody&lt;/code&gt; on the right-hand side.&lt;/p&gt;
&lt;p&gt;If we expand this production, we get:&lt;/p&gt;
&lt;pre class=&quot;language-grammar&quot;&gt;&lt;code class=&quot;language-grammar&quot;&gt;&lt;span class=&quot;token production-name&quot;&gt;AsyncFunctionBody&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;FunctionBody_Await&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In other words, async functions have &lt;code&gt;FunctionBody_Await&lt;/code&gt;, meaning a function body where &lt;code&gt;await&lt;/code&gt; is treated as a keyword.&lt;/p&gt;
&lt;p&gt;On the other hand, if we’re inside a non-async function, &lt;a href=&quot;https://tc39.es/ecma262/#prod-FunctionDeclaration&quot;&gt;the relevant production&lt;/a&gt; is:&lt;/p&gt;
&lt;pre class=&quot;language-grammar&quot;&gt;&lt;code class=&quot;language-grammar&quot;&gt;&lt;span class=&quot;token production-name&quot;&gt;FunctionDeclaration&lt;/span&gt;&lt;span class=&quot;token production-params&quot;&gt;[Yield, Await, Default]&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;BindingIdentifier&lt;/span&gt;&lt;span class=&quot;token production-params&quot;&gt;[?Yield, ?Await]&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;FormalParameters&lt;/span&gt;&lt;span class=&quot;token production-params&quot;&gt;[~Yield, ~Await]&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;FunctionBody&lt;/span&gt;&lt;span class=&quot;token production-params&quot;&gt;[~Yield, ~Await]&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(&lt;code&gt;FunctionDeclaration&lt;/code&gt; has another production, but it’s not relevant for our code example.)&lt;/p&gt;
&lt;p&gt;To avoid combinatorial expansion, let’s ignore the &lt;code&gt;Default&lt;/code&gt; parameter which is not used in this particular production.&lt;/p&gt;
&lt;p&gt;The expanded form of the production is:&lt;/p&gt;
&lt;pre class=&quot;language-grammar&quot;&gt;&lt;code class=&quot;language-grammar&quot;&gt;&lt;span class=&quot;token production-name&quot;&gt;FunctionDeclaration&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;BindingIdentifier&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;FormalParameters&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;FunctionBody&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token production-name&quot;&gt;FunctionDeclaration_Yield&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;BindingIdentifier_Yield&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;FormalParameters&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;FunctionBody&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token production-name&quot;&gt;FunctionDeclaration_Await&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;BindingIdentifier_Await&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;FormalParameters&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;FunctionBody&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token production-name&quot;&gt;FunctionDeclaration_Yield_Await&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;BindingIdentifier_Yield_Await&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;FormalParameters&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;FunctionBody&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this production we always get &lt;code&gt;FunctionBody&lt;/code&gt; and &lt;code&gt;FormalParameters&lt;/code&gt; (without &lt;code&gt;_Yield&lt;/code&gt; and without &lt;code&gt;_Await&lt;/code&gt;), since they are parameterized with &lt;code&gt;[~Yield, ~Await]&lt;/code&gt; in the non-expanded production.&lt;/p&gt;
&lt;p&gt;Function name is treated differently: it gets the parameters &lt;code&gt;_Await&lt;/code&gt; and &lt;code&gt;_Yield&lt;/code&gt; if the left-hand side symbol has them.&lt;/p&gt;
&lt;p&gt;To summarize: Async functions have a &lt;code&gt;FunctionBody_Await&lt;/code&gt; and non-async functions have a &lt;code&gt;FunctionBody&lt;/code&gt; (without &lt;code&gt;_Await&lt;/code&gt;). Since we’re talking about non-generator functions, both our async example function and our non-async example function are parameterized without &lt;code&gt;_Yield&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Maybe it’s hard to remember which one is &lt;code&gt;FunctionBody&lt;/code&gt; and which &lt;code&gt;FunctionBody_Await&lt;/code&gt;. Is &lt;code&gt;FunctionBody_Await&lt;/code&gt; for a function where &lt;code&gt;await&lt;/code&gt; is an identifier, or for a function where &lt;code&gt;await&lt;/code&gt; is a keyword?&lt;/p&gt;
&lt;p&gt;You can think of the &lt;code&gt;_Await&lt;/code&gt; parameter meaning &amp;quot;&lt;code&gt;await&lt;/code&gt; is a keyword&amp;quot;. This approach is also future proof. Imagine a new keyword, &lt;code&gt;blob&lt;/code&gt; being added, but only inside &amp;quot;blobby&amp;quot; functions. Non-blobby non-async non-generators would still have &lt;code&gt;FunctionBody&lt;/code&gt; (without &lt;code&gt;_Await&lt;/code&gt;, &lt;code&gt;_Yield&lt;/code&gt; or &lt;code&gt;_Blob&lt;/code&gt;), exactly like they have now. Blobby functions would have a &lt;code&gt;FunctionBody_Blob&lt;/code&gt;, async blobby functions would have &lt;code&gt;FunctionBody_Await_Blob&lt;/code&gt; and so on. We’d still need to add the &lt;code&gt;Blob&lt;/code&gt; subscript to the productions, but the expanded forms of &lt;code&gt;FunctionBody&lt;/code&gt; for already existing functions stay the same.&lt;/p&gt;
&lt;h3 id=&quot;disallowing-await-as-an-identifier&quot;&gt;Disallowing &lt;code&gt;await&lt;/code&gt; as an identifier &lt;a class=&quot;bookmark&quot; href=&quot;#disallowing-await-as-an-identifier&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Next, we need to find out how &lt;code&gt;await&lt;/code&gt; is disallowed as an identifier if we&#39;re inside a &lt;code&gt;FunctionBody_Await&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We can follow the productions further to see that the &lt;code&gt;_Await&lt;/code&gt; parameter gets carried unchanged from &lt;code&gt;FunctionBody&lt;/code&gt; all the way to the &lt;code&gt;VariableStatement&lt;/code&gt; production we were previously looking at.&lt;/p&gt;
&lt;p&gt;Thus, inside an async function, we’ll have a &lt;code&gt;VariableStatement_Await&lt;/code&gt; and inside a non-async function, we’ll have a &lt;code&gt;VariableStatement&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We can follow the productions further and keep track of the parameters. We already saw the productions for &lt;a href=&quot;https://tc39.es/ecma262/#prod-VariableStatement&quot;&gt;&lt;code&gt;VariableStatement&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre class=&quot;language-grammar&quot;&gt;&lt;code class=&quot;language-grammar&quot;&gt;&lt;span class=&quot;token production-name&quot;&gt;VariableStatement&lt;/span&gt;&lt;span class=&quot;token production-params&quot;&gt;[Yield, Await]&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;VariableDeclarationList&lt;/span&gt;&lt;span class=&quot;token production-params&quot;&gt;[+In, ?Yield, ?Await]&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All productions for &lt;a href=&quot;https://tc39.es/ecma262/#prod-VariableDeclarationList&quot;&gt;&lt;code&gt;VariableDeclarationList&lt;/code&gt;&lt;/a&gt; just carry the parameters on as is:&lt;/p&gt;
&lt;pre class=&quot;language-grammar&quot;&gt;&lt;code class=&quot;language-grammar&quot;&gt;&lt;span class=&quot;token production-name&quot;&gt;VariableDeclarationList&lt;/span&gt;&lt;span class=&quot;token production-params&quot;&gt;[In, Yield, Await]&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;VariableDeclaration&lt;/span&gt;&lt;span class=&quot;token production-params&quot;&gt;[?In, ?Yield, ?Await]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(Here we show only the &lt;a href=&quot;https://tc39.es/ecma262/#prod-VariableDeclaration&quot;&gt;production&lt;/a&gt; relevant to our example.)&lt;/p&gt;
&lt;pre class=&quot;language-grammar&quot;&gt;&lt;code class=&quot;language-grammar&quot;&gt;&lt;span class=&quot;token production-name&quot;&gt;VariableDeclaration&lt;/span&gt;&lt;span class=&quot;token production-params&quot;&gt;[In, Yield, Await]&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;BindingIdentifier&lt;/span&gt;&lt;span class=&quot;token production-params&quot;&gt;[?Yield, ?Await]&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;Initializer&lt;/span&gt;&lt;span class=&quot;token production-params&quot;&gt;[?In, ?Yield, ?Await]&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;opt&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;opt&lt;/code&gt; shorthand means that the right-hand side symbol is optional; there are in fact two productions, one with the optional symbol, and one without.&lt;/p&gt;
&lt;p&gt;In the simple case relevant to our example, &lt;code&gt;VariableStatement&lt;/code&gt; consists of the keyword &lt;code&gt;var&lt;/code&gt;, followed by a single &lt;code&gt;BindingIdentifier&lt;/code&gt; without an initializer, and ending with a semicolon.&lt;/p&gt;
&lt;p&gt;To disallow or allow &lt;code&gt;await&lt;/code&gt; as a &lt;code&gt;BindingIdentifier&lt;/code&gt;, we hope to end up with something like this:&lt;/p&gt;
&lt;pre class=&quot;language-grammar&quot;&gt;&lt;code class=&quot;language-grammar&quot;&gt;&lt;span class=&quot;token production-name&quot;&gt;BindingIdentifier_Await&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;Identifier&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;yield&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token production-name&quot;&gt;BindingIdentifier&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;Identifier&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;yield&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;await&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This would disallow &lt;code&gt;await&lt;/code&gt; as an identifier inside async functions and allow it as an identifier inside non-async functions.&lt;/p&gt;
&lt;p&gt;But the spec doesn’t define it like this, instead we find this &lt;a href=&quot;https://tc39.es/ecma262/#prod-BindingIdentifier&quot;&gt;production&lt;/a&gt;:&lt;/p&gt;
&lt;pre class=&quot;language-grammar&quot;&gt;&lt;code class=&quot;language-grammar&quot;&gt;&lt;span class=&quot;token production-name&quot;&gt;BindingIdentifier&lt;/span&gt;&lt;span class=&quot;token production-params&quot;&gt;[Yield, Await]&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;Identifier&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;yield&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;await&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Expanded, this means the following productions:&lt;/p&gt;
&lt;pre class=&quot;language-grammar&quot;&gt;&lt;code class=&quot;language-grammar&quot;&gt;&lt;span class=&quot;token production-name&quot;&gt;BindingIdentifier_Await&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;Identifier&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;yield&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;await&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token production-name&quot;&gt;BindingIdentifier&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;Identifier&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;yield&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;await&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(We’re omitting the productions for &lt;code&gt;BindingIdentifier_Yield&lt;/code&gt; and &lt;code&gt;BindingIdentifier_Yield_Await&lt;/code&gt; which are not needed in our example.)&lt;/p&gt;
&lt;p&gt;This looks like &lt;code&gt;await&lt;/code&gt; and &lt;code&gt;yield&lt;/code&gt; would be always allowed as identifiers. What’s up with that? Is the whole blog post for nothing?&lt;/p&gt;
&lt;h3 id=&quot;statics-semantics-to-the-rescue&quot;&gt;Statics semantics to the rescue &lt;a class=&quot;bookmark&quot; href=&quot;#statics-semantics-to-the-rescue&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;It turns out that &lt;strong&gt;static semantics&lt;/strong&gt; are needed for forbidding &lt;code&gt;await&lt;/code&gt; as an identifier inside async functions.&lt;/p&gt;
&lt;p&gt;Static semantics describe static rules — that is, rules that are checked before the program runs.&lt;/p&gt;
&lt;p&gt;In this case, the &lt;a href=&quot;https://tc39.es/ecma262/#sec-identifiers-static-semantics-early-errors&quot;&gt;static semantics for &lt;code&gt;BindingIdentifier&lt;/code&gt;&lt;/a&gt; define the following syntax-directed rule:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre class=&quot;language-grammar&quot;&gt;&lt;code class=&quot;language-grammar&quot;&gt;&lt;span class=&quot;token production-name&quot;&gt;BindingIdentifier&lt;/span&gt;&lt;span class=&quot;token production-params&quot;&gt;[Yield, Await]&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;await&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is a Syntax Error if this production has an &lt;code&gt;&lt;sub&gt;[Await]&lt;/sub&gt;&lt;/code&gt; parameter.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Effectively, this forbids the &lt;code&gt;BindingIdentifier_Await : await&lt;/code&gt; production.&lt;/p&gt;
&lt;p&gt;The spec explains that the reason for having this production but defining it as a Syntax Error by the static semantics is because of interference with automatic semicolon insertion (ASI).&lt;/p&gt;
&lt;p&gt;Remember that ASI kicks in when we’re unable to parse a line of code according to the grammar productions. ASI tries to add semicolons to satisfy the requirement that statements and declarations must end with a semicolon. (We’ll describe ASI in more detail in a later episode.)&lt;/p&gt;
&lt;p&gt;Consider the following code (example from the spec):&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;too_few_semicolons&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the grammar disallowed &lt;code&gt;await&lt;/code&gt; as an identifier, ASI would kick in and transform the code into the following grammatically correct code, which also uses &lt;code&gt;let&lt;/code&gt; as an identifier:&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;too_few_semicolons&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This kind of interference with ASI was deemed too confusing, so static semantics were used for disallowing &lt;code&gt;await&lt;/code&gt; as an identifier.&lt;/p&gt;
&lt;h3 id=&quot;disallowed-stringvalues-of-identifiers&quot;&gt;Disallowed &lt;code&gt;StringValues&lt;/code&gt; of identifiers &lt;a class=&quot;bookmark&quot; href=&quot;#disallowed-stringvalues-of-identifiers&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;There’s also another related rule:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre class=&quot;language-grammar&quot;&gt;&lt;code class=&quot;language-grammar&quot;&gt;&lt;span class=&quot;token production-name&quot;&gt;BindingIdentifier&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;Identifier&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is a Syntax Error if this production has an &lt;code&gt;&lt;sub&gt;[Await]&lt;/sub&gt;&lt;/code&gt; parameter and &lt;code&gt;StringValue&lt;/code&gt; of &lt;code&gt;Identifier&lt;/code&gt; is &lt;code&gt;&amp;quot;await&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This might be confusing at first. &lt;a href=&quot;https://tc39.es/ecma262/#prod-Identifier&quot;&gt;&lt;code&gt;Identifier&lt;/code&gt;&lt;/a&gt; is defined like this:&lt;/p&gt;
&lt;!-- markdownlint-disable no-inline-html --&gt;
&lt;pre class=&quot;language-grammar&quot;&gt;&lt;code class=&quot;language-grammar&quot;&gt;&lt;span class=&quot;token production-name&quot;&gt;Identifier&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;IdentifierName&lt;/span&gt; &lt;span class=&quot;token skip&quot;&gt;but not&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;ReservedWord&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- markdownlint-enable no-inline-html --&gt;
&lt;p&gt;&lt;code&gt;await&lt;/code&gt; is a &lt;code&gt;ReservedWord&lt;/code&gt;, so how can an &lt;code&gt;Identifier&lt;/code&gt; ever be &lt;code&gt;await&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;As it turns out, &lt;code&gt;Identifier&lt;/code&gt; cannot be &lt;code&gt;await&lt;/code&gt;, but it can be something else whose &lt;code&gt;StringValue&lt;/code&gt; is &lt;code&gt;&amp;quot;await&amp;quot;&lt;/code&gt; — a different representation of the character sequence &lt;code&gt;await&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tc39.es/ecma262/#sec-identifier-names-static-semantics-stringvalue&quot;&gt;Static semantics for identifier names&lt;/a&gt; define how the &lt;code&gt;StringValue&lt;/code&gt; of an identifier name is computed. For example, the Unicode escape sequence for &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;\u0061&lt;/code&gt;, so &lt;code&gt;\u0061wait&lt;/code&gt; has the &lt;code&gt;StringValue&lt;/code&gt; &lt;code&gt;&amp;quot;await&amp;quot;&lt;/code&gt;. &lt;code&gt;\u0061wait&lt;/code&gt; won’t be recognized as a keyword by the lexical grammar, instead it will be an &lt;code&gt;Identifier&lt;/code&gt;. The static semantics for forbid using it as a variable name inside async functions.&lt;/p&gt;
&lt;p&gt;So this works:&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;old&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; \u0061wait&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And this doesn’t:&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;modern&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; \u0061wait&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Syntax error&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary &lt;a class=&quot;bookmark&quot; href=&quot;#summary&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In this episode, we familiarized ourselves with the lexical grammar, the syntactic grammar, and the shorthands used for defining the syntactic grammar. As an example, we looked into forbidding using &lt;code&gt;await&lt;/code&gt; as an identifier inside async functions but allowing it inside non-async functions.&lt;/p&gt;
&lt;p&gt;Other interesting parts of the syntactic grammar, such as automatic semicolon insertion and cover grammars will be covered in a later episode. Stay tuned!&lt;/p&gt;
</content></entry><entry><title>Pointer Compression in V8</title><link href="https://v8.js.cn/blog/pointer-compression/"/><updated>2020-03-30T00:00:00-00:00</updated><id>https://v8.js.cn/blog/pointer-compression/</id><author><name>Igor Sheludko and Santiago Aboy Solanes, the pointer compressors</name></author><content type="html">&lt;p&gt;There is a constant battle between memory and performance. As users, we would like things to be fast as well as consume as little memory as possible. Unfortunately, usually improving performance comes at a cost of memory consumption (and vice versa).&lt;/p&gt;
&lt;p&gt;Back in 2014 Chrome switched from being a 32-bit process to a 64-bit process. This gave Chrome better &lt;a href=&quot;https://blog.chromium.org/2014/08/64-bits-of-awesome-64-bit-windows_26.html&quot;&gt;security, stability and performance&lt;/a&gt;, but it came at a memory cost since each pointer now occupies eight bytes instead of four. We took on the challenge to reduce this overhead in V8 to try and get back as many wasted 4 bytes as possible.&lt;/p&gt;
&lt;p&gt;Before diving into the implementation, we need to know where we are standing to correctly assess the situation. To measure our memory and performance we use a set of &lt;a href=&quot;https://v8.dev/blog/optimizing-v8-memory&quot;&gt;web pages&lt;/a&gt; that reflect popular real-world websites. The data showed that V8 contributes up to 60% of Chrome’s &lt;a href=&quot;https://www.chromium.org/developers/design-documents/multi-process-architecture&quot;&gt;renderer process&lt;/a&gt; memory consumption on desktop, with an average of 40%.&lt;/p&gt;
&lt;figure&gt;&lt;img src=&quot;https://v8.js.cn/_img/pointer-compression/memory-chrome.svg&quot; alt=&quot;&quot; width=&quot;600&quot; height=&quot;371&quot; loading=&quot;lazy&quot;&gt;&lt;figcaption&gt;V8 memory consumption percentage in Chrome’s renderer memory&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p&gt;Pointer Compression is one of several ongoing efforts in V8 to reduce memory consumption. The idea is very simple: instead of storing 64-bit pointers we can store 32-bit offsets from some “base” address. With such a simple idea, how much can we gain from such a compression in V8?&lt;/p&gt;
&lt;p&gt;The V8 heap contains a whole slew of items, such as floating point values, string characters, interpreter bytecode, and tagged values (see next section for details). Upon inspection of the heap, we discovered that on real-world websites these tagged values occupy around 70% of the V8 heap!&lt;/p&gt;
&lt;p&gt;Let’s take a closer look at what tagged values are.&lt;/p&gt;
&lt;h2 id=&quot;value-tagging-in-v8&quot;&gt;Value tagging in V8 &lt;a class=&quot;bookmark&quot; href=&quot;#value-tagging-in-v8&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;JavaScript values in V8 are represented as objects and allocated on the V8 heap, no matter if they are objects, arrays, numbers or strings. This allows us to represent any value as a pointer to an object.&lt;/p&gt;
&lt;p&gt;Many JavaScript programs perform calculations on integer values, such as incrementing an index in a loop. To avoid us having to allocate a new number object each time an integer is incremented, V8 uses the well-known &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_pointer&quot;&gt;pointer tagging&lt;/a&gt; technique to store additional or alternative data in V8 heap pointers.&lt;/p&gt;
&lt;p&gt;The tag bits serve a dual purpose: they signal either strong/weak pointers to objects located in V8 heap, or a small integer. Hence, the value of an integer can be stored directly in the tagged value, without having to allocate additional storage for it.&lt;/p&gt;
&lt;p&gt;V8 always allocates objects in the heap at word-aligned addresses, which allows it to use the 2 (or 3, depending on the machine word size) least significant bits for tagging. On 32-bit architectures, V8 uses the least significant bit to distinguish Smis from heap object pointers. For heap pointers, it uses the second least significant bit to distinguish strong references from weak ones:&lt;/p&gt;
&lt;pre&gt;
                        |----- 32 bits -----|
Pointer:                |_____address_____&lt;b&gt;w1&lt;/b&gt;|
Smi:                    |___int31_value____&lt;b&gt;0&lt;/b&gt;|
&lt;/pre&gt;
&lt;p&gt;where &lt;em&gt;w&lt;/em&gt; is a bit used for distinguishing strong pointers from the weak ones.&lt;/p&gt;
&lt;p&gt;Note that a Smi value can only carry a 31-bit payload, including the sign bit. In the case of pointers, we have 30 bits that can be used as a heap object address payload. Due to word alignment, the allocation granularity is 4 bytes, which gives us 4 GB of addressable space.&lt;/p&gt;
&lt;p&gt;On 64-bit architectures V8 values look like this:&lt;/p&gt;
&lt;pre&gt;
            |----- 32 bits -----|----- 32 bits -----|
Pointer:    |________________address______________&lt;b&gt;w1&lt;/b&gt;|
Smi:        |____int32_value____|000000000000000000&lt;b&gt;0&lt;/b&gt;|
&lt;/pre&gt;
&lt;p&gt;You may notice that unlike 32-bit architectures, on 64-bit architectures V8 can use 32 bits for the Smi value payload. The implications of 32-bit Smis on pointer compression are discussed in the following sections.&lt;/p&gt;
&lt;h2 id=&quot;compressed-tagged-values-and-new-heap-layout&quot;&gt;Compressed tagged values and new heap layout &lt;a class=&quot;bookmark&quot; href=&quot;#compressed-tagged-values-and-new-heap-layout&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With Pointer Compression, our goal is to somehow fit both kinds of tagged values into 32 bits on 64-bit architectures. We can fit pointers into 32 bits by:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;making sure all V8 objects are allocated within a 4-GB memory range&lt;/li&gt;
&lt;li&gt;representing pointers as offsets within this range&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Having such a hard limit is unfortunate, but V8 in Chrome already has a 2-GB or 4-GB limit on the size of the V8 heap (depending on how powerful the underlying device is), even on 64-bit architectures. Other V8 embedders, such as Node.js, may require bigger heaps. If we impose a maximum of 4 GB, it would mean that these embedders cannot use Pointer Compression.&lt;/p&gt;
&lt;p&gt;The question is now how to update the heap layout to ensure that 32-bit pointers uniquely identify V8 objects.&lt;/p&gt;
&lt;h3 id=&quot;trivial-heap-layout&quot;&gt;Trivial heap layout &lt;a class=&quot;bookmark&quot; href=&quot;#trivial-heap-layout&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The trivial compression scheme would be to allocate objects in the first 4 GB of address space.&lt;/p&gt;
&lt;figure&gt;&lt;img src=&quot;https://v8.js.cn/_img/pointer-compression/heap-layout-0.svg&quot; alt=&quot;&quot; width=&quot;827&quot; height=&quot;260&quot; loading=&quot;lazy&quot;&gt;&lt;figcaption&gt;Trivial heap layout&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p&gt;Unfortunately, this is not an option for V8 since Chrome’s renderer process may need to create multiple V8 instances in the same renderer process, for example for Web/Service Workers. Otherwise, with this scheme all these V8 instances compete for the same 4-GB address space and thus there is a 4-GB memory limit imposed on all V8 instances together.&lt;/p&gt;
&lt;h3 id=&quot;heap-layout%2C-v1&quot;&gt;Heap layout, v1 &lt;a class=&quot;bookmark&quot; href=&quot;#heap-layout%2C-v1&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;If we arrange V8’s heap in a contiguous 4-GB region of address space somewhere else, then an &lt;strong&gt;unsigned&lt;/strong&gt; 32-bit offset from the base uniquely identifies the pointer.&lt;/p&gt;
&lt;figure&gt;
  &lt;img src=&quot;https://v8.js.cn/_img/pointer-compression/heap-layout-1.svg&quot; width=&quot;827&quot; height=&quot;323&quot; alt=&quot;&quot; loading=&quot;lazy&quot;&gt;
  &lt;figcaption&gt;Heap layout, base aligned to start&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;If we also ensure that the base is 4-GB-aligned then the upper 32 bits are the same for all pointers:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;            |----- 32 bits -----|----- 32 bits -----|
Pointer:    |________base_______|______offset_____w1|
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also make Smis compressible by limiting the Smi payload to 31 bits and placing it to the lower 32 bits. Basically, making them similar to Smis on 32-bit architectures.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;         |----- 32 bits -----|----- 32 bits -----|
Smi:     |sssssssssssssssssss|____int31_value___0|
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;where &lt;em&gt;s&lt;/em&gt; is the sign value of the Smi payload. If we have a sign-extended representation, we are able to compress and decompress Smis with just a one-bit arithmetic shift of the 64-bit word.&lt;/p&gt;
&lt;p&gt;Now, we can see that the upper half-word of both pointers and Smis is fully defined by the lower half-word. Then, we can store just the latter in memory, reducing the memory required for storing tagged value by half:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;                    |----- 32 bits -----|----- 32 bits -----|
Compressed pointer:                     |______offset_____w1|
Compressed Smi:                         |____int31_value___0|
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Given that the base is 4-GB-aligned, the compression is just a truncation:&lt;/p&gt;
&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;uint64_t&lt;/span&gt; uncompressed_tagged&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;uint32_t&lt;/span&gt; compressed_tagged &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;uint32_t&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;uncompressed_tagged&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The decompression code, however, is a bit more complicated. We need to distinguish between sign-extending the Smi and zero-extending the pointer, as well as whether or not to add in the base.&lt;/p&gt;
&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;uint32_t&lt;/span&gt; compressed_tagged&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;uint64_t&lt;/span&gt; uncompressed_tagged&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;compressed_tagged &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token comment&quot;&gt;// pointer case&lt;/span&gt;&lt;br&gt;  uncompressed_tagged &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; base &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;compressed_tagged&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token comment&quot;&gt;// Smi case&lt;/span&gt;&lt;br&gt;  uncompressed_tagged &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int64_t&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;compressed_tagged&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s try to change the compression scheme to simplify the decompression code.&lt;/p&gt;
&lt;h3 id=&quot;heap-layout%2C-v2&quot;&gt;Heap layout, v2 &lt;a class=&quot;bookmark&quot; href=&quot;#heap-layout%2C-v2&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;If instead of having the base at the beginning of the 4 GB we put the base in the &lt;em&gt;middle&lt;/em&gt;, we can treat the compressed value as a &lt;strong&gt;signed&lt;/strong&gt; 32-bit offset from the base. Note that the whole reservation is not 4-GB-aligned anymore but the base is.&lt;/p&gt;
&lt;figure&gt;&lt;img src=&quot;https://v8.js.cn/_img/pointer-compression/heap-layout-2.svg&quot; alt=&quot;&quot; width=&quot;827&quot; height=&quot;363&quot; loading=&quot;lazy&quot;&gt;&lt;figcaption&gt;Heap layout, base aligned to the middle&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p&gt;In this new layout, the compression code stays the same.&lt;/p&gt;
&lt;p&gt;The decompression code, however, becomes nicer. Sign-extension is now common for both Smi and pointer cases and the only branch is on whether to add the base in the pointer case.&lt;/p&gt;
&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;int32_t&lt;/span&gt; compressed_tagged&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;// Common code for both pointer and Smi cases&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;int64_t&lt;/span&gt; uncompressed_tagged &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int64_t&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;compressed_tagged&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;uncompressed_tagged &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token comment&quot;&gt;// pointer case&lt;/span&gt;&lt;br&gt;  uncompressed_tagged &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; base&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The performance of branches in code depends on the branch prediction unit in the CPU. We thought that if we were to implement the decompression in a branchless way, we could get better performance. With a small amount of bit magic, we can write a branchless version of the code above:&lt;/p&gt;
&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;int32_t&lt;/span&gt; compressed_tagged&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;// Same code for both pointer and Smi cases&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;int64_t&lt;/span&gt; sign_extended_tagged &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int64_t&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;compressed_tagged&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;int64_t&lt;/span&gt; selector_mask &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;sign_extended_tagged &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;// Mask is 0 in case of Smi or all 1s in case of pointer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;int64_t&lt;/span&gt; uncompressed_tagged &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;br&gt;    sign_extended_tagged &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;base &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt; selector_mask&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, we decided to start with the branchless implementation.&lt;/p&gt;
&lt;h2 id=&quot;performance-evolution&quot;&gt;Performance evolution &lt;a class=&quot;bookmark&quot; href=&quot;#performance-evolution&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&quot;initial-performance&quot;&gt;Initial performance &lt;a class=&quot;bookmark&quot; href=&quot;#initial-performance&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We measured performance on &lt;a href=&quot;https://v8.dev/blog/retiring-octane#the-genesis-of-octane&quot;&gt;Octane&lt;/a&gt; — a peak-performance benchmark we have used in the past. Although we are no longer focusing on improving peak performance in our day-to-day work, we also don’t want to regress peak performance, particularly for something as performance-sensitive as &lt;em&gt;all pointers&lt;/em&gt;. Octane continues to be a good benchmark for this task.&lt;/p&gt;
&lt;p&gt;This graph shows Octane’s score on x64 architecture while we were optimizing and polishing the Pointer Compression implementation. In the graph, higher is better. The red line is the existing full-sized-pointer x64 build, while the green line is the pointer compressed version.&lt;/p&gt;
&lt;figure&gt;&lt;img src=&quot;https://v8.js.cn/_img/pointer-compression/perf-octane-1.svg&quot; alt=&quot;&quot; width=&quot;913&quot; height=&quot;218&quot; loading=&quot;lazy&quot;&gt;&lt;figcaption&gt;First round of Octane’s improvements&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p&gt;With the first working implementation, we had a ~35% regression gap.&lt;/p&gt;
&lt;h4 id=&quot;bump-(1)%2C-%2B7%25&quot;&gt;Bump (1), +7% &lt;a class=&quot;bookmark&quot; href=&quot;#bump-(1)%2C-%2B7%25&quot;&gt;#&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;First we validated our “branchless is faster” hypothesis, by comparing the branchless decompression with the branchful one. It turned out that our hypothesis was wrong, and the branchful version was 7% faster on x64. That was quite a significant difference!&lt;/p&gt;
&lt;p&gt;Let’s take a look at the x64 assembly.&lt;/p&gt;
&lt;div class=&quot;table-wrapper&quot;&gt;
&lt;!-- markdownlint-disable no-space-in-code --&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Decompression&lt;/th&gt;
&lt;th&gt;Branchless&lt;/th&gt;
&lt;th&gt;Branchful&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;p&gt;Code&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;pre class=&quot;language-asm&quot;&gt;&lt;code class=&quot;language-asm&quot;&gt;movsxlq &lt;span class=&quot;token register variable&quot;&gt;r11&lt;/span&gt;,&lt;span class=&quot;token operator&quot;&gt;[&lt;/span&gt;…&lt;span class=&quot;token operator&quot;&gt;]&lt;/span&gt;&lt;br&gt;movl &lt;span class=&quot;token register variable&quot;&gt;r10&lt;/span&gt;,&lt;span class=&quot;token register variable&quot;&gt;r11&lt;/span&gt;&lt;br&gt;andl &lt;span class=&quot;token register variable&quot;&gt;r10&lt;/span&gt;,&lt;span class=&quot;token number&quot;&gt;0x1&lt;/span&gt;&lt;br&gt;negq &lt;span class=&quot;token register variable&quot;&gt;r10&lt;/span&gt;&lt;br&gt;andq &lt;span class=&quot;token register variable&quot;&gt;r10&lt;/span&gt;,&lt;span class=&quot;token register variable&quot;&gt;r13&lt;/span&gt;&lt;br&gt;addq &lt;span class=&quot;token register variable&quot;&gt;r11&lt;/span&gt;,&lt;span class=&quot;token register variable&quot;&gt;r10&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;pre class=&quot;language-asm&quot;&gt;&lt;code class=&quot;language-asm&quot;&gt;movsxlq &lt;span class=&quot;token register variable&quot;&gt;r11&lt;/span&gt;,&lt;span class=&quot;token operator&quot;&gt;[&lt;/span&gt;…&lt;span class=&quot;token operator&quot;&gt;]&lt;/span&gt;&lt;br&gt;testb &lt;span class=&quot;token register variable&quot;&gt;r11&lt;/span&gt;,&lt;span class=&quot;token number&quot;&gt;0x1&lt;/span&gt;&lt;br&gt;jz done&lt;br&gt;addq &lt;span class=&quot;token register variable&quot;&gt;r11&lt;/span&gt;,&lt;span class=&quot;token register variable&quot;&gt;r13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token label function&quot;&gt;done:&lt;/span&gt;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td rowspan=&quot;4&quot;&gt;Summary&lt;/td&gt;
&lt;td&gt;20 bytes&lt;/td&gt;
&lt;td&gt;13 bytes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6 instructions executed&lt;/td&gt;
&lt;td&gt;3 or 4 instructions executed&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;no branches&lt;/td&gt;
&lt;td&gt;1 branch&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1 additional register&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;!-- markdownlint-enable no-space-in-code --&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;r13&lt;/strong&gt; here is a dedicated register used for the base value. Notice how the branchless code is both bigger, and requires more registers.&lt;/p&gt;
&lt;p&gt;On Arm64, we observed the same - the branchful version was clearly faster on powerful CPUs (although the code size was the same for both cases).&lt;/p&gt;
&lt;div class=&quot;table-wrapper&quot;&gt;
&lt;!-- markdownlint-disable no-space-in-code --&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Decompression&lt;/th&gt;
&lt;th&gt;Branchless&lt;/th&gt;
&lt;th&gt;Branchful&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;p&gt;Code&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;pre class=&quot;language-asm&quot;&gt;&lt;code class=&quot;language-asm&quot;&gt;ldur &lt;span class=&quot;token register variable&quot;&gt;w6&lt;/span&gt;, &lt;span class=&quot;token operator&quot;&gt;[&lt;/span&gt;…&lt;span class=&quot;token operator&quot;&gt;]&lt;/span&gt;&lt;br&gt;sbfx &lt;span class=&quot;token register variable&quot;&gt;x16&lt;/span&gt;, &lt;span class=&quot;token register variable&quot;&gt;x6&lt;/span&gt;, &lt;span class=&quot;token number&quot;&gt;#0&lt;/span&gt;, &lt;span class=&quot;token number&quot;&gt;#1&lt;/span&gt;&lt;br&gt;and &lt;span class=&quot;token register variable&quot;&gt;x16&lt;/span&gt;, &lt;span class=&quot;token register variable&quot;&gt;x16&lt;/span&gt;, &lt;span class=&quot;token register variable&quot;&gt;x26&lt;/span&gt;&lt;br&gt;add &lt;span class=&quot;token register variable&quot;&gt;x6&lt;/span&gt;, &lt;span class=&quot;token register variable&quot;&gt;x16&lt;/span&gt;, &lt;span class=&quot;token register variable&quot;&gt;w6&lt;/span&gt;, sxtw&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;pre class=&quot;language-asm&quot;&gt;&lt;code class=&quot;language-asm&quot;&gt;ldur &lt;span class=&quot;token register variable&quot;&gt;w6&lt;/span&gt;, &lt;span class=&quot;token operator&quot;&gt;[&lt;/span&gt;…&lt;span class=&quot;token operator&quot;&gt;]&lt;/span&gt;&lt;br&gt;sxtw &lt;span class=&quot;token register variable&quot;&gt;x6&lt;/span&gt;, &lt;span class=&quot;token register variable&quot;&gt;w6&lt;/span&gt;&lt;br&gt;tbz &lt;span class=&quot;token register variable&quot;&gt;w6&lt;/span&gt;, &lt;span class=&quot;token number&quot;&gt;#0&lt;/span&gt;, #done&lt;br&gt;add &lt;span class=&quot;token register variable&quot;&gt;x6&lt;/span&gt;, &lt;span class=&quot;token register variable&quot;&gt;x26&lt;/span&gt;, &lt;span class=&quot;token register variable&quot;&gt;x6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token label function&quot;&gt;done:&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td rowspan=&quot;4&quot;&gt;Summary&lt;/td&gt;
&lt;td&gt;16 bytes&lt;/td&gt;
&lt;td&gt;16 bytes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4 instructions executed&lt;/td&gt;
&lt;td&gt;3 or 4 instructions executed&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;no branches&lt;/td&gt;
&lt;td&gt;1 branch&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1 additional register&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;!-- markdownlint-enable no-space-in-code --&gt;
&lt;/div&gt;
&lt;p&gt;On low-end Arm64 devices we observed almost no performance difference in either direction.&lt;/p&gt;
&lt;p&gt;Our takeaway is: branch predictors in modern CPUs are very good, and code size (particularly execution path length) affected performance more.&lt;/p&gt;
&lt;h4 id=&quot;bump-(2)%2C-%2B2%25&quot;&gt;Bump (2), +2% &lt;a class=&quot;bookmark&quot; href=&quot;#bump-(2)%2C-%2B2%25&quot;&gt;#&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://v8.dev/docs/turbofan&quot;&gt;TurboFan&lt;/a&gt; is V8’s optimizing compiler, built around a concept called “Sea of Nodes”. In short, each operation is represented as a node in a graph (See a more detailed version &lt;a href=&quot;https://v8.dev/blog/turbofan-jit&quot;&gt;in this blog post&lt;/a&gt;). These nodes have various dependencies, including both data-flow and control-flow.&lt;/p&gt;
&lt;p&gt;There are two operations that are crucial for Pointer Compression: Loads and Stores, since they connect the V8 heap with the rest of the pipeline. If we were to decompress every time we loaded a compressed value from the heap, and compress it before we store it, then the pipeline could just keep working as it otherwise did in full-pointer mode. Thus we added new explicit value operations in the node graph - Decompress and Compress.&lt;/p&gt;
&lt;p&gt;There are cases where the decompression is not actually necessary. For example, if a compressed value is loaded from somewhere only to be then stored to a new location.&lt;/p&gt;
&lt;p&gt;In order to optimize unnecessary operations, we implemented a new “Decompression Elimination” phase in TurboFan. Its job is to eliminate decompressions directly followed by compressions. Since these nodes might not be directly next to each other it also tries to propagate decompressions through the graph, with the hope of encountering a compress down the line and eliminating them both. This gave us a 2% improvement of Octane’ score.&lt;/p&gt;
&lt;h4 id=&quot;bump-(3)%2C-%2B2%25&quot;&gt;Bump (3), +2% &lt;a class=&quot;bookmark&quot; href=&quot;#bump-(3)%2C-%2B2%25&quot;&gt;#&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;While we were looking at the generated code, we noticed that the decompression of a value that had just been loaded produced code that was a bit too verbose:&lt;/p&gt;
&lt;pre class=&quot;language-asm&quot;&gt;&lt;code class=&quot;language-asm&quot;&gt;movl &lt;span class=&quot;token register variable&quot;&gt;rax&lt;/span&gt;, &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;mem&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;   &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; load&lt;br&gt;movlsxlq &lt;span class=&quot;token register variable&quot;&gt;rax&lt;/span&gt;, &lt;span class=&quot;token register variable&quot;&gt;rax&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; sign extend&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once we fixed that to sign extend the value loaded from memory directly:&lt;/p&gt;
&lt;pre class=&quot;language-asm&quot;&gt;&lt;code class=&quot;language-asm&quot;&gt;movlsxlq &lt;span class=&quot;token register variable&quot;&gt;rax&lt;/span&gt;, &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;mem&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;so got yet another 2% improvement.&lt;/p&gt;
&lt;h4 id=&quot;bump-(4)%2C-%2B11%25&quot;&gt;Bump (4), +11% &lt;a class=&quot;bookmark&quot; href=&quot;#bump-(4)%2C-%2B11%25&quot;&gt;#&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;TurboFan optimization phases work by using pattern matching on the graph: once a sub-graph matches a certain pattern it is replaced with a semantically equivalent (but better) sub-graph or instruction.&lt;/p&gt;
&lt;p&gt;Unsuccessful attempts to find a match are not an explicit failure. The presence of explicit Decompress/Compress operations in the graph caused previously successful pattern matching attempts to no longer succeed, resulting in optimizations silently failing.&lt;/p&gt;
&lt;p&gt;One example of a “broken” optimization was &lt;a href=&quot;https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43823.pdf&quot;&gt;allocation preternuring&lt;/a&gt;. Once we updated the pattern matching to be aware of the new compression/decompression nodes we got another 11% improvement.&lt;/p&gt;
&lt;h3 id=&quot;further-improvements&quot;&gt;Further improvements &lt;a class=&quot;bookmark&quot; href=&quot;#further-improvements&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;figure&gt;&lt;img src=&quot;https://v8.js.cn/_img/pointer-compression/perf-octane-2.svg&quot; alt=&quot;&quot; width=&quot;859&quot; height=&quot;178&quot; loading=&quot;lazy&quot;&gt;&lt;figcaption&gt;Second round of Octane’s improvements&lt;/figcaption&gt;&lt;/figure&gt;
&lt;h4 id=&quot;bump-(5)%2C-%2B0.5%25&quot;&gt;Bump (5), +0.5% &lt;a class=&quot;bookmark&quot; href=&quot;#bump-(5)%2C-%2B0.5%25&quot;&gt;#&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;While implementing the Decompression Elimination in TurboFan we learned a lot. The explicit Decompression/Compression node approach had the following properties:&lt;/p&gt;
&lt;p&gt;Pros:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Explicitness of such operations allowed us to optimize unnecessary decompressions by doing canonical pattern matching of sub-graphs.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;But, as we continued the implementation, we discovered cons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A combinatorial explosion of possible conversion operations because of new internal value representations became unmanageable. We could now have compressed pointer, compressed Smi, and compressed any (compressed values which we could be either pointer or Smi), in addition to the existing set of representations (tagged Smi, tagged pointer, tagged any, word8, word16, word32, word64, float32, float64, simd128).&lt;/li&gt;
&lt;li&gt;Some existing optimizations based on graph pattern-matching silently didn’t fire, which caused regressions here and there. Although we found and fixed some of them, the complexity of TurboFan continued to increase.&lt;/li&gt;
&lt;li&gt;The register allocator was increasingly unhappy about the amount of nodes in the graph, and quite often generated bad code.&lt;/li&gt;
&lt;li&gt;The larger node graphs slowed the TurboFan optimization phases, and increased memory consumption during compilation.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We decided to take a step back and think of a simpler way of supporting Pointer Compression in TurboFan.  The new approach is to drop the Compressed Pointer / Smi / Any representations, and make all explicit Compression / Decompression nodes implicit within Stores and Loads with the assumption that we always decompress before loading and compress before storing.&lt;/p&gt;
&lt;p&gt;We also added a new phase in TurboFan that would replace the “Decompression Elimination” one. This new phase would recognize when we don’t actually need to compress or decompress and update the Loads and Stores accordingly. Such an approach significantly reduced the complexity of Pointer Compression support in TurboFan and improved the quality of generated code.&lt;/p&gt;
&lt;p&gt;The new implementation was as effective as the initial version and gave another 0.5% improvement.&lt;/p&gt;
&lt;h4 id=&quot;bump-(6)%2C-%2B2.5%25&quot;&gt;Bump (6), +2.5% &lt;a class=&quot;bookmark&quot; href=&quot;#bump-(6)%2C-%2B2.5%25&quot;&gt;#&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;We were getting close to performance parity, but the gap was still there. We had to come up with fresher ideas. One of them was: what if we ensure that any code that deals with Smi values never “looks” at the upper 32 bits?&lt;/p&gt;
&lt;p&gt;Let’s remember the decompression implementation:&lt;/p&gt;
&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// Old decompression implementation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;int64_t&lt;/span&gt; uncompressed_tagged &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int64_t&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;compressed_tagged&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;uncompressed_tagged &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token comment&quot;&gt;// pointer case&lt;/span&gt;&lt;br&gt;  uncompressed_tagged &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; base&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the upper 32 bits of a Smi are ignored, we can assume them to be undefined. Then, we can avoid the special casing between the pointer and Smi cases and unconditionally add the base when decompressing, even for Smis! We call this approach “Smi-corrupting”.&lt;/p&gt;
&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// New decompression implementation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;int64_t&lt;/span&gt; uncompressed_tagged &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; base &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int64_t&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;compressed_tagged&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Also, since we don’t care about sign extending the Smi anymore, this change allows us to return to heap layout v1. This is the one with the base pointing to the beginning of the 4GB reservation.&lt;/p&gt;
&lt;figure&gt;
  &lt;img src=&quot;https://v8.js.cn/_img/pointer-compression/heap-layout-1.svg&quot; width=&quot;827&quot; height=&quot;323&quot; alt=&quot;&quot; loading=&quot;lazy&quot;&gt;
  &lt;figcaption&gt;Heap layout, base aligned to start&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;In terms of the decompression code, it changes a sign-extension operation to a zero-extension, which is just as cheap. However, this simplifies things on the runtime (C++) side. For example, the address space region reservation code (see the &lt;a href=&quot;#some-implementation-details&quot;&gt;Some implementation details&lt;/a&gt; section).&lt;/p&gt;
&lt;p&gt;Here’s the assembly code for comparison:&lt;/p&gt;
&lt;div class=&quot;table-wrapper&quot;&gt;
&lt;!-- markdownlint-disable no-space-in-code --&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Decompression&lt;/th&gt;
&lt;th&gt;Branchful&lt;/th&gt;
&lt;th&gt;Smi-corrupting&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;p&gt;Code&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;pre class=&quot;language-asm&quot;&gt;&lt;code class=&quot;language-asm&quot;&gt;movsxlq &lt;span class=&quot;token register variable&quot;&gt;r11&lt;/span&gt;,&lt;span class=&quot;token operator&quot;&gt;[&lt;/span&gt;…&lt;span class=&quot;token operator&quot;&gt;]&lt;/span&gt;&lt;br&gt;testb &lt;span class=&quot;token register variable&quot;&gt;r11&lt;/span&gt;,&lt;span class=&quot;token number&quot;&gt;0x1&lt;/span&gt;&lt;br&gt;jz done&lt;br&gt;addq &lt;span class=&quot;token register variable&quot;&gt;r11&lt;/span&gt;,&lt;span class=&quot;token register variable&quot;&gt;r13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token label function&quot;&gt;done:&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;pre class=&quot;language-asm&quot;&gt;&lt;code class=&quot;language-asm&quot;&gt;movl &lt;span class=&quot;token register variable&quot;&gt;r11&lt;/span&gt;,&lt;span class=&quot;token operator&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token register variable&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0x13&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;]&lt;/span&gt;&lt;br&gt;addq &lt;span class=&quot;token register variable&quot;&gt;r11&lt;/span&gt;,&lt;span class=&quot;token register variable&quot;&gt;r13&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td rowspan=&quot;3&quot;&gt;Summary&lt;/td&gt;
&lt;td&gt;13 bytes&lt;/td&gt;
&lt;td&gt;7 bytes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3 or 4 instructions executed&lt;/td&gt;
&lt;td&gt;2 instructions executed&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1 branch&lt;/td&gt;
&lt;td&gt;no branches&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;!-- markdownlint-enable no-space-in-code --&gt;
&lt;/div&gt;
&lt;p&gt;So, we adapted all the Smi-using code pieces in V8 to the new compression scheme, which gave us another 2.5% improvement.&lt;/p&gt;
&lt;h3 id=&quot;remaining-gap&quot;&gt;Remaining gap &lt;a class=&quot;bookmark&quot; href=&quot;#remaining-gap&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The remaining performance gap is explained by two optimizations for 64-bit builds that we had to disable due to fundamental incompatibility with Pointer Compression.&lt;/p&gt;
&lt;figure&gt;&lt;img src=&quot;https://v8.js.cn/_img/pointer-compression/perf-octane-3.svg&quot; alt=&quot;&quot; width=&quot;858&quot; height=&quot;300&quot; loading=&quot;lazy&quot;&gt;&lt;figcaption&gt;Final round of Octane’s improvements&lt;/figcaption&gt;&lt;/figure&gt;
&lt;h4 id=&quot;32-bit-smi-optimization-(7)%2C--1%25&quot;&gt;32-bit Smi optimization (7), -1% &lt;a class=&quot;bookmark&quot; href=&quot;#32-bit-smi-optimization-(7)%2C--1%25&quot;&gt;#&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Let’s recall how Smis look like in full pointer mode on 64-bit architectures.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        |----- 32 bits -----|----- 32 bits -----|
Smi:    |____int32_value____|0000000000000000000|
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;32-bit Smi has the following benefits:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;it can represent a bigger range of integers without the need to box them into number objects; and&lt;/li&gt;
&lt;li&gt;such a shape provides direct access to the 32-bit value when reading/writing.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This optimization can’t be done with Pointer Compression, because there’s no space in the 32-bit compressed pointer due to having the bit which distinguishes pointers from Smis. If we disable 32-bit smis in the full-pointer 64-bit version we see a 1% regression of the Octane score.&lt;/p&gt;
&lt;h4 id=&quot;double-field-unboxing-(8)%2C--3%25&quot;&gt;Double field unboxing (8), -3% &lt;a class=&quot;bookmark&quot; href=&quot;#double-field-unboxing-(8)%2C--3%25&quot;&gt;#&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;This optimization tries to store floating point values directly in the object’s fields under certain assumptions. This has the objective of reducing the amount of number object allocations even more than Smis do alone.&lt;/p&gt;
&lt;p&gt;Imagine the following JavaScript code:&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; y&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;y &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; p &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3.1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5.3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Generally speaking, if we look at how the object p looks like in memory, we’ll see something like this:&lt;/p&gt;
&lt;figure&gt;&lt;img src=&quot;https://v8.js.cn/_img/pointer-compression/heap-point-1.svg&quot; alt=&quot;&quot; width=&quot;832&quot; height=&quot;232&quot; loading=&quot;lazy&quot;&gt;&lt;figcaption&gt;Object &lt;code&gt;p&lt;/code&gt; in memory&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p&gt;You can read more about hidden classes and properties and elements backing stores in &lt;a href=&quot;https://v8.dev/blog/fast-properties&quot;&gt;this article&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;On 64-bit architectures, double values are the same size as pointers. So, if we assume that Point’s fields always contain number values, we can store them directly in the object fields.&lt;/p&gt;
&lt;figure&gt;&lt;img src=&quot;https://v8.js.cn/_img/pointer-compression/heap-point-2.svg&quot; alt=&quot;&quot; width=&quot;832&quot; height=&quot;112&quot; loading=&quot;lazy&quot;&gt;&lt;/figure&gt;
&lt;p&gt;If the assumption breaks for some field, say after executing this line:&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; q &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;ab&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;then number values for the y property must be stored boxed instead. Additionally, if there is speculatively-optimized code somewhere that relies on this assumption it must no longer be used and must be thrown away (deoptimized). The reason for such a “field type” generalization is to minimize the number of shapes of objects created from the same constructor function, which in turn is necessary for more stable performance.&lt;/p&gt;
&lt;figure&gt;&lt;img src=&quot;https://v8.js.cn/_img/pointer-compression/heap-point-3.svg&quot; alt=&quot;&quot; width=&quot;832&quot; height=&quot;262&quot; loading=&quot;lazy&quot;&gt;&lt;figcaption&gt;Objects &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; in memory&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p&gt;If applied, double field unboxing gives the following benefits:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;provides direct access to the floating point data through the object pointer, avoiding the additional dereference via number object; and&lt;/li&gt;
&lt;li&gt;allows us to generate smaller and faster optimized code for tight loops doing a lot of double field accesses (for example in number-crunching applications)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With Pointer Compression enabled, the double values simply do not fit into the compressed fields anymore. However, in the future we may adapt this optimization for Pointer Compression.&lt;/p&gt;
&lt;p&gt;Note that number-crunching code which requires high throughput could be rewritten in an optimizable way even without this double field unboxing optimization (in a way compatible with Pointer Compression), by storing data in Float64 TypedArrays, or even by using &lt;a href=&quot;https://webassembly.github.io/spec/core/&quot;&gt;Wasm&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&quot;more-improvements-(9)%2C-1%25&quot;&gt;More improvements (9), 1% &lt;a class=&quot;bookmark&quot; href=&quot;#more-improvements-(9)%2C-1%25&quot;&gt;#&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Finally, a bit of fine-tuning of the decompression elimination optimization in TurboFan gave another 1% performance improvement.&lt;/p&gt;
&lt;h2 id=&quot;some-implementation-details&quot;&gt;Some implementation details &lt;a class=&quot;bookmark&quot; href=&quot;#some-implementation-details&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In order to simplify integration of Pointer Compression into existing code, we decided to decompress values on every load and compress them on every store. Thus changing only the storage format of tagged values while keeping the execution format unchanged.&lt;/p&gt;
&lt;h3 id=&quot;native-code-side&quot;&gt;Native code side &lt;a class=&quot;bookmark&quot; href=&quot;#native-code-side&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In order to be able to generate efficient code when decompression is required the base value must always be available. Luckily V8 already had a dedicated register always pointing to a “roots table” containing references to JavaScript and V8-internal objects which must be always available (for example, undefined, null, true, false and many more). This register is called “root register” and it is used for generating smaller and &lt;a href=&quot;https://v8.dev/blog/embedded-builtins&quot;&gt;shareable builtins code&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;So, we put the roots table into the V8 heap reservation area and thus the root register became usable for both purposes - as a root pointer and as a base value for decompression.&lt;/p&gt;
&lt;h3 id=&quot;c%2B%2B-side&quot;&gt;C++ side &lt;a class=&quot;bookmark&quot; href=&quot;#c%2B%2B-side&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;V8 runtime accesses objects in V8 heap through C++ classes providing a convenient view on the data stored in the heap. Note that V8 objects are rather &lt;a href=&quot;https://en.wikipedia.org/wiki/Passive_data_structure&quot;&gt;POD&lt;/a&gt;-like structures than C++ objects. The helper “view” classes contain just one uintptr_t field with a respective tagged value. Since the view classes are word-sized we can pass them around by value with zero overhead (many thanks to modern C++ compilers).&lt;/p&gt;
&lt;p&gt;Here is an pseudo example of a helper class:&lt;/p&gt;
&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// Hidden class&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt; &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;br&gt;  …&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;inline&lt;/span&gt; DescriptorArray &lt;span class=&quot;token function&quot;&gt;instance_descriptors&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;  …&lt;br&gt;  &lt;span class=&quot;token comment&quot;&gt;// The actual tagged pointer value stored in the Map view object.&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; uintptr_t ptr_&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;br&gt;DescriptorArray Map&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;instance_descriptors&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;  uintptr_t field_address &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;br&gt;      &lt;span class=&quot;token function&quot;&gt;FieldAddress&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;ptr_&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; kInstanceDescriptorsOffset&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;br&gt;  uintptr_t da &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;reinterpret_cast&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;uintptr_t&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;field_address&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;DescriptorArray&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;da&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In order to minimize the number of changes required for a first run of the pointer compressed version we integrated the computation of the base value required for decompression into getters.&lt;/p&gt;
&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;inline&lt;/span&gt; uintptr_t &lt;span class=&quot;token function&quot;&gt;GetBaseForPointerCompression&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;uintptr_t address&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token comment&quot;&gt;// Round address down to 4 GB&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; uintptr_t kBaseAlignment &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; address &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;kBaseAlignment&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;br&gt;DescriptorArray Map&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;instance_descriptors&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;  uintptr_t field_address &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;br&gt;      &lt;span class=&quot;token function&quot;&gt;FieldAddress&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;ptr_&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; kInstanceDescriptorsOffset&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;uint32_t&lt;/span&gt; compressed_da &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;reinterpret_cast&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;uint32_t&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;field_address&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;br&gt;  uintptr_t base &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;GetBaseForPointerCompression&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;ptr_&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;  uintptr_t da &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; base &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; compressed_da&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;DescriptorArray&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;da&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Performance measurements confirmed that the computation of base in every load hurts performance. The reason is that C++ compilers don’t know that the result of GetBaseForPointerCompression() call is the same for any address from the V8 heap and thus the compiler is not able to merge computations of base values. Given that the code consists of several instructions and a 64-bit constant this results in a significant code bloat.&lt;/p&gt;
&lt;p&gt;In order to address this issue we reused V8 instance pointer as a base for decompression (remember the V8 instance data in the heap layout). This pointer is usually available in runtime functions, so we simplified the getters code by requiring an V8 instance pointer and it recovered the regressions:&lt;/p&gt;
&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;DescriptorArray Map&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;instance_descriptors&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Isolate&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; isolate&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;  uintptr_t field_address &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;br&gt;      &lt;span class=&quot;token function&quot;&gt;FieldAddress&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;ptr_&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; kInstanceDescriptorsOffset&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;uint32_t&lt;/span&gt; compressed_da &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;reinterpret_cast&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;uint32_t&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;field_address&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;br&gt;  &lt;span class=&quot;token comment&quot;&gt;// No rounding is needed since the Isolate pointer is already the base.&lt;/span&gt;&lt;br&gt;  uintptr_t base &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;reinterpret_cast&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;uintptr_t&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;isolate&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;  uintptr_t da &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;DecompressTagged&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;base&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; compressed_value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;DescriptorArray&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;da&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;results&quot;&gt;Results &lt;a class=&quot;bookmark&quot; href=&quot;#results&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Let’s take a look at Pointer Compression’s final numbers! For these results, we use the same browsing tests that we introduced at the beginning of this blog post. As a reminder, they are browsing user stories that we found were representative of usage of real-world websites.&lt;/p&gt;
&lt;p&gt;In them, we observed that Pointer Compression reduces &lt;strong&gt;V8 heap size up to 43%&lt;/strong&gt;! In turn, it reduces &lt;strong&gt;Chrome’s renderer process memory up to 20%&lt;/strong&gt; on Desktop.&lt;/p&gt;
&lt;figure&gt;&lt;img src=&quot;https://v8.js.cn/_img/pointer-compression/v8-heap-memory.svg&quot; alt=&quot;&quot; width=&quot;600&quot; height=&quot;371&quot; loading=&quot;lazy&quot;&gt;&lt;figcaption&gt;Memory savings when browsing in Windows 10&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p&gt;Another important thing to notice is that not every website improves the same amount. For example, V8 heap memory used to be bigger on Facebook than New York Times, but with Pointer Compression it is actually the reverse. This difference can be explained by the fact that some websites have more Tagged values than others.&lt;/p&gt;
&lt;p&gt;In addition to these memory improvements we have also seen real-world performance improvements. On real websites we utilize less CPU and garbage collector time!&lt;/p&gt;
&lt;figure&gt;&lt;img src=&quot;https://v8.js.cn/_img/pointer-compression/performance-improvements.svg&quot; alt=&quot;&quot; width=&quot;600&quot; height=&quot;371&quot; loading=&quot;lazy&quot;&gt;&lt;figcaption&gt;Improvements in CPU and garbage collection time&lt;/figcaption&gt;&lt;/figure&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion &lt;a class=&quot;bookmark&quot; href=&quot;#conclusion&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The journey to get here was no bed of roses but it was worth our while. &lt;a href=&quot;https://github.com/v8/v8/search?o=desc&amp;amp;q=repo%3Av8%2Fv8+%22%5Bptr-compr%5D%22&amp;amp;s=committer-date&amp;amp;type=Commits&quot;&gt;300+ commits&lt;/a&gt; later, V8 with Pointer Compression uses as much memory as if we were running a 32-bit application, while having the performance of a 64-bit one.&lt;/p&gt;
&lt;p&gt;We are always looking forward to improving things, and have the following related tasks in our pipeline:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Improve quality of generated assembly code. We know that in some cases we can generate less code which should improve performance.&lt;/li&gt;
&lt;li&gt;Address related performance regressions, including a mechanism which allows unboxing double fields again in a pointer-compression-friendly way.&lt;/li&gt;
&lt;li&gt;Explore the idea of supporting bigger heaps, in the 8 to 16 GB range.&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><title>Understanding the ECMAScript spec, part 2</title><link href="https://v8.js.cn/blog/understanding-ecmascript-part-2/"/><updated>2020-03-02T00:00:00-00:00</updated><id>https://v8.js.cn/blog/understanding-ecmascript-part-2/</id><author><name>Marja Hölttä, speculative specification spectator</name></author><content type="html">&lt;p&gt;Let’s practice our awesome spec reading skills some more. If you haven’t had a look at the previous episodes, now it’s a good time to do so!&lt;/p&gt;
&lt;p&gt;In &lt;a href=&quot;https://v8.js.cn/blog/understanding-ecmascript-part-1&quot;&gt;part 1 of this series&lt;/a&gt; we read through a simple method — &lt;code&gt;Object.prototype.hasOwnProperty&lt;/code&gt; — and &lt;strong&gt;abstract operations&lt;/strong&gt; it invokes. We familiarized ourselves with the shorthands &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;!&lt;/code&gt; related to error handling. We encountered &lt;strong&gt;language types&lt;/strong&gt;, &lt;strong&gt;specification types&lt;/strong&gt;, &lt;strong&gt;internal slots&lt;/strong&gt;, and &lt;strong&gt;internal methods&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&quot;ready-for-part-2%3F&quot;&gt;Ready for part 2? &lt;a class=&quot;bookmark&quot; href=&quot;#ready-for-part-2%3F&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;A fun way to get to know the spec is to start with a JavaScript feature we know is there, and find out how it’s specified.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Warning! This episode contains copy-pasted algorithms from the &lt;a href=&quot;https://tc39.es/ecma262/&quot;&gt;ECMAScript spec&lt;/a&gt; as of February 2020. They’ll eventually be out of date.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We know that properties are looked up in the prototype chain: if an object doesn’t have the property we’re trying to read, we walk up the prototype chain until we find it (or find an object which no longer has a prototype).&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; o1 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; foo&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;99&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; o2 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;Object&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setPrototypeOf&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;o2&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; o1&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;o2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;foo&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;// → 99&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;prototype-walk&quot;&gt;Where’s the prototype walk defined?  &lt;a class=&quot;bookmark&quot; href=&quot;#prototype-walk&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Let’s try to find out where this behavior is defined. A good place to start is a list of &lt;a href=&quot;https://tc39.es/ecma262/#sec-object-internal-methods-and-internal-slots&quot;&gt;Object Internal Methods&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;There’s both &lt;code&gt;[[GetOwnProperty]]&lt;/code&gt; and &lt;code&gt;[[Get]]&lt;/code&gt; — we’re interested in the version that isn’t restricted to &lt;em&gt;own&lt;/em&gt; properties, so we’ll go with &lt;code&gt;[[Get]]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Unfortunately, the &lt;a href=&quot;https://tc39.es/ecma262/#sec-property-descriptor-specification-type&quot;&gt;Property Descriptor specification type&lt;/a&gt; also has a field called &lt;code&gt;[[Get]]&lt;/code&gt;, so while browsing the spec for &lt;code&gt;[[Get]]&lt;/code&gt;, we need to carefully distinguish between the two independent usages.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[[Get]]&lt;/code&gt; is an &lt;strong&gt;essential internal method&lt;/strong&gt;. &lt;strong&gt;Ordinary objects&lt;/strong&gt; implement the default behavior for essential internal methods. &lt;strong&gt;Exotic objects&lt;/strong&gt; can define their own internal method &lt;code&gt;[[Get]]&lt;/code&gt; which deviates from the default behavior. In this post, we focus on ordinary objects.&lt;/p&gt;
&lt;p&gt;The default implementation for &lt;code&gt;[[Get]]&lt;/code&gt; delegates to &lt;code&gt;OrdinaryGet&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;ecmascript-algorithm&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://tc39.es/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver&quot;&gt;&lt;code&gt;[[Get]] ( P, Receiver )&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;When the &lt;code&gt;[[Get]]&lt;/code&gt; internal method of &lt;code&gt;O&lt;/code&gt; is called with property key &lt;code&gt;P&lt;/code&gt; and ECMAScript language value &lt;code&gt;Receiver&lt;/code&gt;, the following steps are taken:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Return &lt;code&gt;? OrdinaryGet(O, P, Receiver)&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;We’ll see shortly that &lt;code&gt;Receiver&lt;/code&gt; is the value which is used as the &lt;strong&gt;this value&lt;/strong&gt; when calling a getter function of an accessor property.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;OrdinaryGet&lt;/code&gt; is defined like this:&lt;/p&gt;
&lt;div class=&quot;ecmascript-algorithm&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://tc39.es/ecma262/#sec-ordinaryget&quot;&gt;&lt;code&gt;OrdinaryGet ( O, P, Receiver )&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;When the abstract operation &lt;code&gt;OrdinaryGet&lt;/code&gt; is called with Object &lt;code&gt;O&lt;/code&gt;, property key &lt;code&gt;P&lt;/code&gt;, and ECMAScript language value &lt;code&gt;Receiver&lt;/code&gt;, the following steps are taken:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Assert: &lt;code&gt;IsPropertyKey(P)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Let &lt;code&gt;desc&lt;/code&gt; be &lt;code&gt;? O.[[GetOwnProperty]](P)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;desc&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt;, then
&lt;ol&gt;
&lt;li&gt;Let &lt;code&gt;parent&lt;/code&gt; be &lt;code&gt;? O.[[GetPrototypeOf]]()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;parent&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, return &lt;code&gt;undefined&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Return &lt;code&gt;? parent.[[Get]](P, Receiver)&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;IsDataDescriptor(desc)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, return &lt;code&gt;desc.[[Value]]&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Assert: &lt;code&gt;IsAccessorDescriptor(desc)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Let &lt;code&gt;getter&lt;/code&gt; be &lt;code&gt;desc.[[Get]]&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;getter&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt;, return &lt;code&gt;undefined&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Return &lt;code&gt;? Call(getter, Receiver)&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;The prototype chain walk is inside step 3: if we don’t find the property as an own property, we call the prototype’s &lt;code&gt;[[Get]]&lt;/code&gt; method which delegates to &lt;code&gt;OrdinaryGet&lt;/code&gt; again. If we still don’t find the property, we call its prototype’s &lt;code&gt;[[Get]]&lt;/code&gt; method, which delegates to &lt;code&gt;OrdinaryGet&lt;/code&gt; again, and so on, until we either find the property or reach an object without a prototype.&lt;/p&gt;
&lt;p&gt;Let’s look at how this algorithm works when we access &lt;code&gt;o2.foo&lt;/code&gt;. First we invoke &lt;code&gt;OrdinaryGet&lt;/code&gt; with &lt;code&gt;O&lt;/code&gt; being &lt;code&gt;o2&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; being &lt;code&gt;&amp;quot;foo&amp;quot;&lt;/code&gt;. &lt;code&gt;O.[[GetOwnProperty]](&amp;quot;foo&amp;quot;)&lt;/code&gt; returns &lt;code&gt;undefined&lt;/code&gt;, since &lt;code&gt;o2&lt;/code&gt; doesn’t have an own property called &lt;code&gt;&amp;quot;foo&amp;quot;&lt;/code&gt;, so we take the if branch in step 3. In step 3.a, we set &lt;code&gt;parent&lt;/code&gt; to the prototype of &lt;code&gt;o2&lt;/code&gt; which is &lt;code&gt;o1&lt;/code&gt;. &lt;code&gt;parent&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, so we don’t return in step 3.b. In step 3.c, we call the parent’s &lt;code&gt;[[Get]]&lt;/code&gt; method with property key &lt;code&gt;&amp;quot;foo&amp;quot;&lt;/code&gt;, and return whatever it returns.&lt;/p&gt;
&lt;p&gt;The parent (&lt;code&gt;o1&lt;/code&gt;) is an ordinary object, so its &lt;code&gt;[[Get]]&lt;/code&gt; method invokes &lt;code&gt;OrdinaryGet&lt;/code&gt; again, this time with &lt;code&gt;O&lt;/code&gt; being &lt;code&gt;o1&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; being &lt;code&gt;&amp;quot;foo&amp;quot;&lt;/code&gt;. &lt;code&gt;o1&lt;/code&gt; has an own property called &lt;code&gt;&amp;quot;foo&amp;quot;&lt;/code&gt;, so in step 2, &lt;code&gt;O.[[GetOwnProperty]](&amp;quot;foo&amp;quot;)&lt;/code&gt; returns the associated Property Descriptor and we store it in &lt;code&gt;desc&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tc39.es/ecma262/#sec-property-descriptor-specification-type&quot;&gt;Property Descriptor&lt;/a&gt; is a specification type. Data Property Descriptors store the value of the property directly in the &lt;code&gt;[[Value]]&lt;/code&gt; field. Accessor Property Descriptors store the accessor functions in fields &lt;code&gt;[[Get]]&lt;/code&gt; and/or &lt;code&gt;[[Set]]&lt;/code&gt;. In this case, the Property Descriptor associated with &lt;code&gt;&amp;quot;foo&amp;quot;&lt;/code&gt; is a data Property Descriptor.&lt;/p&gt;
&lt;p&gt;The data Property Descriptor we stored in &lt;code&gt;desc&lt;/code&gt; in step 2 is not &lt;code&gt;undefined&lt;/code&gt;, so we don’t take the &lt;code&gt;if&lt;/code&gt; branch in step 3. Next we execute step 4. The Property Descriptor is a data Property Descriptor, so we return its &lt;code&gt;[[Value]]&lt;/code&gt; field, &lt;code&gt;99&lt;/code&gt;, in step 4, and we’re done.&lt;/p&gt;
&lt;h2 id=&quot;receiver&quot;&gt;What’s &lt;code&gt;Receiver&lt;/code&gt; and where is it coming from? &lt;a class=&quot;bookmark&quot; href=&quot;#receiver&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;Receiver&lt;/code&gt; parameter is only used in the case of accessor properties in step 8. It’s passed as the &lt;strong&gt;this value&lt;/strong&gt; when calling the getter function of an accessor property.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;OrdinaryGet&lt;/code&gt; passes the original &lt;code&gt;Receiver&lt;/code&gt; throughout the recursion, unchanged (step 3.c). Let’s find out where the &lt;code&gt;Receiver&lt;/code&gt; is originally coming from!&lt;/p&gt;
&lt;p&gt;Searching for places where &lt;code&gt;[[Get]]&lt;/code&gt; is called we find an abstract operation &lt;code&gt;GetValue&lt;/code&gt; which operates on References. Reference is a specification type, consisting of a base value, the referenced name, and a strict reference flag. In the case of &lt;code&gt;o2.foo&lt;/code&gt;, the base value is the Object &lt;code&gt;o2&lt;/code&gt;, the referenced name is the String &lt;code&gt;&amp;quot;foo&amp;quot;&lt;/code&gt;, and the strict reference flag is &lt;code&gt;false&lt;/code&gt;, since the example code is sloppy.&lt;/p&gt;
&lt;h3 id=&quot;side-track%3A-why-is-reference-not-a-record%3F&quot;&gt;Side track: Why is Reference not a Record? &lt;a class=&quot;bookmark&quot; href=&quot;#side-track%3A-why-is-reference-not-a-record%3F&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Side track: Reference is not a Record, even though it sounds like it could be. It contains three components, which could equally well be expressed as three named fields. Reference is not a Record only because of historical reasons.&lt;/p&gt;
&lt;h3 id=&quot;back-to-getvalue&quot;&gt;Back to &lt;code&gt;GetValue&lt;/code&gt; &lt;a class=&quot;bookmark&quot; href=&quot;#back-to-getvalue&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Let’s look at how &lt;code&gt;GetValue&lt;/code&gt; is defined:&lt;/p&gt;
&lt;div class=&quot;ecmascript-algorithm&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://tc39.es/ecma262/#sec-getvalue&quot;&gt;&lt;code&gt;GetValue ( V )&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;ReturnIfAbrupt(V)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;Type(V)&lt;/code&gt; is not &lt;code&gt;Reference&lt;/code&gt;, return &lt;code&gt;V&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Let &lt;code&gt;base&lt;/code&gt; be &lt;code&gt;GetBase(V)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;IsUnresolvableReference(V)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, throw a &lt;code&gt;ReferenceError&lt;/code&gt; exception.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;IsPropertyReference(V)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then
&lt;ol&gt;
&lt;li&gt;If &lt;code&gt;HasPrimitiveBase(V)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then
&lt;ol&gt;
&lt;li&gt;Assert: In this case, &lt;code&gt;base&lt;/code&gt; will never be &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Set &lt;code&gt;base&lt;/code&gt; to &lt;code&gt;! ToObject(base)&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Return &lt;code&gt;? base.[[Get]](GetReferencedName(V), GetThisValue(V))&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Else,
&lt;ol&gt;
&lt;li&gt;Assert: &lt;code&gt;base&lt;/code&gt; is an Environment Record.&lt;/li&gt;
&lt;li&gt;Return &lt;code&gt;? base.GetBindingValue(GetReferencedName(V), IsStrictReference(V))&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;The Reference in our example is &lt;code&gt;o2.foo&lt;/code&gt;, which is a property reference. So we take branch 5. We don’t take the branch in 5.a, since the base (&lt;code&gt;o2&lt;/code&gt;) is not &lt;a href=&quot;https://v8.js.cn/blog/react-cliff#javascript-types&quot;&gt;a primitive value&lt;/a&gt; (a Number, String, Symbol, BigInt, Boolean, Undefined, or Null).&lt;/p&gt;
&lt;p&gt;Then we call &lt;code&gt;[[Get]]&lt;/code&gt; in step 5.b. The &lt;code&gt;Receiver&lt;/code&gt; we pass is &lt;code&gt;GetThisValue(V)&lt;/code&gt;. In this case, it’s just the base value of the Reference:&lt;/p&gt;
&lt;div class=&quot;ecmascript-algorithm&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://tc39.es/ecma262/#sec-getthisvalue&quot;&gt;&lt;code&gt;GetThisValue( V )&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Assert: &lt;code&gt;IsPropertyReference(V)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;IsSuperReference(V)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then
&lt;ol&gt;
&lt;li&gt;Return the value of the &lt;code&gt;thisValue&lt;/code&gt; component of the reference &lt;code&gt;V&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Return &lt;code&gt;GetBase(V)&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;For &lt;code&gt;o2.foo&lt;/code&gt;, we don’t take the branch in step 2, since it’s not a Super Reference (such as &lt;code&gt;super.foo&lt;/code&gt;), but we take step 3 and return the base value of the Reference which is &lt;code&gt;o2&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Piecing everything together, we find out that we set the &lt;code&gt;Receiver&lt;/code&gt; to be the base of the original Reference, and then we keep it unchanged during the prototype chain walk. Finally, if the property we find is an accessor property, we use the &lt;code&gt;Receiver&lt;/code&gt; as the &lt;strong&gt;this value&lt;/strong&gt; when calling it.&lt;/p&gt;
&lt;p&gt;In particular, the &lt;strong&gt;this value&lt;/strong&gt; inside a getter refers to the original object where we tried to get the property from, not the one where we found the property during the prototype chain walk.&lt;/p&gt;
&lt;p&gt;Let’s try it out!&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; o1 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; x&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; o2 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; x&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;50&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;Object&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setPrototypeOf&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;o2&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; o1&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;o2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;foo&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;// → 50&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, we have an accessor property called &lt;code&gt;foo&lt;/code&gt; and we define a getter for it. The getter returns &lt;code&gt;this.x&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Then we access &lt;code&gt;o2.foo&lt;/code&gt; - what does the getter return?&lt;/p&gt;
&lt;p&gt;We found out that when we call the getter, the &lt;strong&gt;this value&lt;/strong&gt; is the object where we originally tried to get the property from, not the object where we found it. In this case the &lt;strong&gt;this value&lt;/strong&gt; is &lt;code&gt;o2&lt;/code&gt;, not &lt;code&gt;o1&lt;/code&gt;. We can verify that by checking whether the getter returns &lt;code&gt;o2.x&lt;/code&gt; or &lt;code&gt;o1.x&lt;/code&gt;, and indeed, it returns &lt;code&gt;o2.x&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It works! We were able to predict the behavior of this code snippet based on what we read in the spec.&lt;/p&gt;
&lt;h2 id=&quot;property-access-get&quot;&gt;Accessing properties — why does it invoke &lt;code&gt;[[Get]]&lt;/code&gt;? &lt;a class=&quot;bookmark&quot; href=&quot;#property-access-get&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Where does the spec say that the Object internal method &lt;code&gt;[[Get]]&lt;/code&gt; will get invoked when accessing a property like &lt;code&gt;o2.foo&lt;/code&gt;? Surely that has to be defined somewhere. Don’t take my word for it!&lt;/p&gt;
&lt;p&gt;We found out that the Object internal method &lt;code&gt;[[Get]]&lt;/code&gt; is called from the abstract operation &lt;code&gt;GetValue&lt;/code&gt; which operates on References. But where is &lt;code&gt;GetValue&lt;/code&gt; called from?&lt;/p&gt;
&lt;h3 id=&quot;memberexpression&quot;&gt;Runtime semantics for &lt;code&gt;MemberExpression&lt;/code&gt; &lt;a class=&quot;bookmark&quot; href=&quot;#memberexpression&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The grammar rules of the spec define the syntax of the language. &lt;a href=&quot;https://tc39.es/ecma262/#sec-runtime-semantics&quot;&gt;Runtime semantics&lt;/a&gt; define what the syntactic constructs “mean” (how to evaluate them at runtime).&lt;/p&gt;
&lt;p&gt;If you’re not familiar with &lt;a href=&quot;https://en.wikipedia.org/wiki/Context-free_grammar&quot;&gt;context-free grammars&lt;/a&gt;, it’s a good idea to have a look now!&lt;/p&gt;
&lt;p&gt;We’ll take a deeper look into the grammar rules in a later episode, let’s keep it simple for now! In particular, we can ignore the subscripts (&lt;code&gt;Yield&lt;/code&gt;, &lt;code&gt;Await&lt;/code&gt; and so on) in the productions for this episode.&lt;/p&gt;
&lt;p&gt;The following productions describe what a &lt;a href=&quot;https://tc39.es/ecma262/#prod-MemberExpression&quot;&gt;&lt;code&gt;MemberExpression&lt;/code&gt;&lt;/a&gt; looks like:&lt;/p&gt;
&lt;pre class=&quot;language-grammar&quot;&gt;&lt;code class=&quot;language-grammar&quot;&gt;&lt;span class=&quot;token production-name&quot;&gt;MemberExpression&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;:&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;PrimaryExpression&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;MemberExpression&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;Expression&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;]&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;MemberExpression&lt;/span&gt; &lt;span class=&quot;token literal&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;IdentifierName&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;MemberExpression&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;TemplateLiteral&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;SuperProperty&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token production-name&quot;&gt;MetaProperty&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token literal&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;MemberExpression&lt;/span&gt; &lt;span class=&quot;token production-name&quot;&gt;Arguments&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we have 7 productions for &lt;code&gt;MemberExpression&lt;/code&gt;. A &lt;code&gt;MemberExpression&lt;/code&gt; can be just a &lt;code&gt;PrimaryExpression&lt;/code&gt;. Alternatively, a &lt;code&gt;MemberExpression&lt;/code&gt; can be constructed from another &lt;code&gt;MemberExpression&lt;/code&gt; and &lt;code&gt;Expression&lt;/code&gt; by piecing them together: &lt;code&gt;MemberExpression [ Expression ]&lt;/code&gt;, for example &lt;code&gt;o2[&#39;foo&#39;]&lt;/code&gt;. Or it can be &lt;code&gt;MemberExpression . IdentifierName&lt;/code&gt;, for example &lt;code&gt;o2.foo&lt;/code&gt; — this is the production relevant for our example.&lt;/p&gt;
&lt;p&gt;Runtime semantics for the production &lt;code&gt;MemberExpression : MemberExpression . IdentifierName&lt;/code&gt; define the set of steps to take when evaluating it:&lt;/p&gt;
&lt;div class=&quot;ecmascript-algorithm&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://tc39.es/ecma262/#sec-property-accessors-runtime-semantics-evaluation&quot;&gt;Runtime Semantics: Evaluation for &lt;code&gt;MemberExpression : MemberExpression . IdentifierName&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Let &lt;code&gt;baseReference&lt;/code&gt; be the result of evaluating &lt;code&gt;MemberExpression&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Let &lt;code&gt;baseValue&lt;/code&gt; be &lt;code&gt;? GetValue(baseReference)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If the code matched by this &lt;code&gt;MemberExpression&lt;/code&gt; is strict mode code, let &lt;code&gt;strict&lt;/code&gt; be &lt;code&gt;true&lt;/code&gt;; else let &lt;code&gt;strict&lt;/code&gt; be &lt;code&gt;false&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Return &lt;code&gt;? EvaluatePropertyAccessWithIdentifierKey(baseValue, IdentifierName, strict)&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;The algorithm delegates to the abstract operation &lt;code&gt;EvaluatePropertyAccessWithIdentifierKey&lt;/code&gt;, so we need to read it too:&lt;/p&gt;
&lt;div class=&quot;ecmascript-algorithm&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://tc39.es/ecma262/#sec-evaluate-property-access-with-identifier-key&quot;&gt;&lt;code&gt;EvaluatePropertyAccessWithIdentifierKey( baseValue, identifierName, strict )&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The abstract operation &lt;code&gt;EvaluatePropertyAccessWithIdentifierKey&lt;/code&gt; takes as arguments a value &lt;code&gt;baseValue&lt;/code&gt;, a Parse Node &lt;code&gt;identifierName&lt;/code&gt;, and a Boolean argument &lt;code&gt;strict&lt;/code&gt;. It performs the following steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Assert: &lt;code&gt;identifierName&lt;/code&gt; is an &lt;code&gt;IdentifierName&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Let &lt;code&gt;bv&lt;/code&gt; be &lt;code&gt;? RequireObjectCoercible(baseValue)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Let &lt;code&gt;propertyNameString&lt;/code&gt; be &lt;code&gt;StringValue&lt;/code&gt; of &lt;code&gt;identifierName&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Return a value of type Reference whose base value component is &lt;code&gt;bv&lt;/code&gt;, whose referenced name component is &lt;code&gt;propertyNameString&lt;/code&gt;, and whose strict reference flag is &lt;code&gt;strict&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;That is: &lt;code&gt;EvaluatePropertyAccessWithIdentifierKey&lt;/code&gt; constructs a Reference which uses the provided &lt;code&gt;baseValue&lt;/code&gt; as the base, the string value of &lt;code&gt;identifierName&lt;/code&gt; as the property name, and &lt;code&gt;strict&lt;/code&gt; as the strict mode flag.&lt;/p&gt;
&lt;p&gt;Eventually this Reference gets passed to &lt;code&gt;GetValue&lt;/code&gt;. This is defined in several places in the spec, depending on how the Reference ends up being used.&lt;/p&gt;
&lt;h3 id=&quot;memberexpression-as-a-parameter&quot;&gt;&lt;code&gt;MemberExpression&lt;/code&gt; as a parameter &lt;a class=&quot;bookmark&quot; href=&quot;#memberexpression-as-a-parameter&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In our example, we use the property access as a parameter:&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;o2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;foo&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case, the behavior is defined in the runtime semantics of &lt;code&gt;ArgumentList&lt;/code&gt; production which calls &lt;code&gt;GetValue&lt;/code&gt; on the argument:&lt;/p&gt;
&lt;div class=&quot;ecmascript-algorithm&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://tc39.es/ecma262/#sec-argument-lists-runtime-semantics-argumentlistevaluation&quot;&gt;Runtime Semantics: &lt;code&gt;ArgumentListEvaluation&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ArgumentList : AssignmentExpression&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Let &lt;code&gt;ref&lt;/code&gt; be the result of evaluating &lt;code&gt;AssignmentExpression&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Let &lt;code&gt;arg&lt;/code&gt; be &lt;code&gt;? GetValue(ref)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Return a List whose sole item is &lt;code&gt;arg&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;o2.foo&lt;/code&gt; doesn’t look like an &lt;code&gt;AssignmentExpression&lt;/code&gt; but it is one, so this production is applicable. To find out why, you can check out this &lt;a href=&quot;https://v8.js.cn/blog/extras/understanding-ecmascript-part-2-extra&quot;&gt;extra content&lt;/a&gt;, but it’s not strictly necessary at this point.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;AssignmentExpression&lt;/code&gt; in step 1 is &lt;code&gt;o2.foo&lt;/code&gt;. &lt;code&gt;ref&lt;/code&gt;, the result of evaluating &lt;code&gt;o2.foo&lt;/code&gt;, is the above mentioned Reference. In step 2 we call &lt;code&gt;GetValue&lt;/code&gt; on it. Thus, we know that the Object internal method &lt;code&gt;[[Get]]&lt;/code&gt; will get invoked, and the prototype chain walk will occur.&lt;/p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary &lt;a class=&quot;bookmark&quot; href=&quot;#summary&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In this episode, we looked at how the spec defines a language feature, in this case prototype lookup, across all the different layers: the syntactic constructs that trigger the feature and the algorithms defining it.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</content></entry><entry><title>V8 release v8.1</title><link href="https://v8.js.cn/blog/v8-release-81/"/><updated>2020-02-25T00:00:00-00:00</updated><id>https://v8.js.cn/blog/v8-release-81/</id><author><name>Dominik Inführ, international(ization) man of mystery</name></author><content type="html">&lt;p&gt;Every six weeks, we create a new branch of V8 as part of our &lt;a href=&quot;https://v8.dev/docs/release-process&quot;&gt;release process&lt;/a&gt;. Each version is branched from V8’s Git master immediately before a Chrome Beta milestone. Today we’re pleased to announce our newest branch, &lt;a href=&quot;https://chromium.googlesource.com/v8/v8.git/+log/branch-heads/8.1&quot;&gt;V8 version 8.1&lt;/a&gt;, which is in beta until its release in coordination with Chrome 81 Stable in several weeks. V8 v8.1 is filled with all sorts of developer-facing goodies. This post provides a preview of some of the highlights in anticipation of the release.&lt;/p&gt;
&lt;h2 id=&quot;javascript&quot;&gt;JavaScript &lt;a class=&quot;bookmark&quot; href=&quot;#javascript&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&quot;intl.displaynames&quot;&gt;&lt;code&gt;Intl.DisplayNames&lt;/code&gt; &lt;a class=&quot;bookmark&quot; href=&quot;#intl.displaynames&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The new &lt;code&gt;Intl.DisplayNames&lt;/code&gt; API lets programmers display translated names of languages, regions, scripts, and currencies with ease.&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; zhLanguageNames &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Intl&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;DisplayNames&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;zh-Hant&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;language&#39;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; enRegionNames &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Intl&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;DisplayNames&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;en&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;region&#39;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; itScriptNames &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Intl&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;DisplayNames&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;it&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;script&#39;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; deCurrencyNames &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Intl&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;DisplayNames&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;de&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;currency&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;br&gt;zhLanguageNames&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;fr&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;// → &#39;法文&#39;&lt;/span&gt;&lt;br&gt;enRegionNames&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;US&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;// → &#39;United States&#39;&lt;/span&gt;&lt;br&gt;itScriptNames&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;Latn&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;// → &#39;latino&#39;&lt;/span&gt;&lt;br&gt;deCurrencyNames&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;JPY&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;// → &#39;Japanischer Yen&#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Shift the burden of translation data maintenance to the runtime today! See &lt;a href=&quot;https://v8.dev/features/intl-displaynames&quot;&gt;our feature explainer&lt;/a&gt; for details on the full API and more examples.&lt;/p&gt;
&lt;h2 id=&quot;v8-api&quot;&gt;V8 API &lt;a class=&quot;bookmark&quot; href=&quot;#v8-api&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Please use &lt;code&gt;git log branch-heads/8.0..branch-heads/8.1 include/v8.h&lt;/code&gt; to get a list of the API changes.&lt;/p&gt;
&lt;p&gt;Developers with an &lt;a href=&quot;https://v8.js.cn/docs/source-code#using-git&quot;&gt;active V8 checkout&lt;/a&gt; can use &lt;code&gt;git checkout -b 8.1 -t branch-heads/8.1&lt;/code&gt; to experiment with the new features in V8 v8.1. Alternatively you can &lt;a href=&quot;https://www.google.com/chrome/browser/beta.html&quot;&gt;subscribe to Chrome’s Beta channel&lt;/a&gt; and try the new features out yourself soon.&lt;/p&gt;
</content></entry></feed>